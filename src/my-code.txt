App.tsx:
import React, { useCallback, useEffect, useState } from 'react';
import { Header } from './components/Header';
import { SideMenu } from './components/SideMenu';
import { Outlet } from 'react-router-dom';
import { RootStore } from './store/models/RootStore';
import { RootStoreProvider } from './store/common/RootStoreContext';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { emitter, useEventEmitter } from './services/mittEmitter';
import {
  EVENT_CHAT_SESSION_DELETED,
  EVENT_ERROR,
  EVENT_SET_ACTIVE_ASSISTANT,
  EVENT_SET_ASSISTANT_VALUES,
  EVENT_SHOW_ADD_ASSISTANT_MODAL,
  EVENT_SHOW_NOTIFICATION,
} from './utils/eventNames';
import { DialogManager } from './components/admin/DialogManager';
import { ChatContainer } from './components/chat-container/ChatContainer';
import { pusher } from './services/PusherService';
import {
  LOCALSTORAGE_COMPANY_ID,
  LOCALSTORAGE_USER_ID,
  getLocalStorageItem,
  getSessionByCompanyAndUserId,
} from './services/api/sessionService';

const rootStore = RootStore.create({
  assistants: [],  
  users: [],  
});

const App = () => {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [screenHeight, setScreenHeight] = useState(0);

  const toastHandler = useCallback((message: string) => {
    toast(message);
  }, []);

  useEventEmitter<string>(EVENT_CHAT_SESSION_DELETED, toastHandler);
  useEventEmitter<string>(EVENT_ERROR, toastHandler);
  useEventEmitter<string>(EVENT_SHOW_NOTIFICATION, toastHandler);

  useEffect(() => {
    const channel = pusher.subscribe('sb');

    channel.bind('createNewAssistant', async function (data: any) {
      const newAssistantData = data.message; // contains name, description, prompt
      console.log(newAssistantData);
      emitter.emit(EVENT_SHOW_ADD_ASSISTANT_MODAL, 'Add Assistant');
      await new Promise((resolve) => setTimeout(resolve, 100));
      emitter.emit(EVENT_SET_ASSISTANT_VALUES, newAssistantData);
    });

    channel.bind('setAssistant', async function (data: any) {
      const assistantData = data.message; // contains name, description, prompt
      console.log(assistantData);
      emitter.emit(EVENT_SET_ACTIVE_ASSISTANT, assistantData._id);
    });

    return () => {
      channel.unbind_all();
      pusher.unsubscribe('sb');
    };
  }, []);

  const getHeight = useCallback(
    () =>
      window.visualViewport ? window.visualViewport.height : window.innerHeight,
    []
  );

  const handleClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
    if (event.target !== event.currentTarget && isMenuOpen) {
      setIsMenuOpen(false);
    }
  };

  const handleResize = () => {
    setScreenHeight(getHeight());
  };

  useEffect(() => {
    setScreenHeight(getHeight());

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
    window.visualViewport?.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleResize);
      window.visualViewport?.removeEventListener('resize', handleResize);
    };
  }, [getHeight]);

  const style = { height: `${screenHeight}px` };

  const loadUserSession = async () => {

    try {

      const session = await getSessionByCompanyAndUserId(
        getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) as string,
        getLocalStorageItem(LOCALSTORAGE_USER_ID) as string
      );

      
      await rootStore.loadAssistants();
      rootStore.sessionStore.setActiveSession(session);
      await rootStore.loadInboxMessages();

      console.log('session loaded', session);
  
    } catch (error) {
      console.log('session not found');
    }

    
    
  };

  useEffect(() => {

    rootStore.sessionStore.loadSessions();    
    rootStore.loadCompanies();
    rootStore.loadUsers();    
    rootStore.loadActions();

    loadUserSession();
    

  }, [rootStore]);

  return (
    <RootStoreProvider value={rootStore}>
      <div
        style={style}
        className="flex flex-col h-screen inset-0"
        onClick={handleClick}
      >
        <Header onMenuClick={() => setIsMenuOpen(true)} />
        <SideMenu isOpen={isMenuOpen} closeMenu={() => setIsMenuOpen(false)} />
        <ToastContainer />
        <DialogManager />
        <ChatContainer />
        <Outlet />
      </div>
    </RootStoreProvider>
  );
};

export default App;


Router.tsx:
import { Chat } from './pages/Chat';
import { NotFound } from './pages/NotFound';
import { Admin } from './pages/Admin';
import React from 'react';
import { createBrowserRouter } from 'react-router-dom'; // Import the Outlet component
import App from './App';
import { ChatbotView } from './pages/admin/ChatbotView';
import { ChatRouteLoader } from './components/ChatRouteLoader';
import { AssistantsPage } from './pages/admin/AssistantsPage';
import { EditAssistantPage } from './pages/admin/EditAssistantPage';
import { CompaniesPage } from './pages/admin/CompaniesPage';
import { SessionsPage } from './pages/admin/SessionsPage';
import { UsersPage } from './pages/admin/UsersPage';
import { InboxPage } from './pages/admin/inbox/InboxPage';
import { EditCompanyPage } from './pages/admin/EditCompanyPage';
import { ActionsPage } from './pages/admin/ActionsPage';

export const browserRouter = createBrowserRouter([
  {
    element: <App />,
    children: [
      {
        path: '/',
        element: <Chat />,
      },
      {
        path: '/chat/:sessionId',
        element: (
          <ChatRouteLoader>
            <Chat />
          </ChatRouteLoader>
        ),
      },
      {
        path: '/other',
        element: <Chat />,
      },
      {
        path: '/admin',
        element: <Admin />,
        children: [
          {
            index: true,
            element: <CompaniesPage />,
          },
          // {
          //   path: "/chat-sessions/:id",
          //   element: <ChatSessionView />,
          // },
          {
            path: 'chatbots/:key',
            element: <ChatbotView />,
          },
          {
            path: 'assistants',
            element: <AssistantsPage />,
          },
          {
            path: 'assistants/:key',
            element: <EditAssistantPage />,
          },
          {
            path: 'companies',
            element: <CompaniesPage />,
          },
          {
            path: 'actions',
            element: <ActionsPage />,
          },
          {
            path: 'companies/:id',
            element: <EditCompanyPage />,
          },
          {
            path: 'sessions',
            element: <SessionsPage />,
          },
          {
            path: 'users',
            element: <UsersPage />,
          },
          {
            path: 'inbox',
            element: <InboxPage />,
          },
        ],
      },
      { path: '*', element: <NotFound /> },
    ],
  },
]);


atoms/dataStore-old.ts:
import { atom, useRecoilValue } from 'recoil';

export enum SenderType {
  user = 'user',
  bot = 'bot',
}

export const ChatBotNotLoaded = 'ChatBotNotLoaded';

export interface Message {
  _id?: string;
  content: any;
  textTranslated?: string;
  role?: string;
  timestamp?: number;
  // senderType?: SenderType.user | SenderType.bot;
  audio?: ArrayBuffer;
}

export const getMessageText = (message: Message) => {
  if (message.role === SenderType.user) {
    return message.content;
  }
  return message.textTranslated || message.content;
};

export const sanitizeMessageText = (text: string) => {
  // turn "hello {{ some : data , "here" : "oi" }} world" into "hello world"
  return text.replace(/{{.*?}}/g, '');
};

export const getMessageTextGPT = (message: Message) => {
  if (message.role === SenderType.user) {
    return message.textTranslated || message.content;
  }
  return message.content;
};

export interface UserProfile {
  name: string;
  avatar: string;
  activeChatBot: string;
  isAudioPlaying: boolean;
}

export interface ChatBotStore {
  key: string;
  name: string;
  description: string;
  avatar: string;
  bgImage: string;
  backgroundImage?: string;
  prompt: string;
  logo: string;
  autoTranslate: boolean;
  autoTranslateTarget: string;
  temperature: number;
  ttsLanguage: string;
  ttsActor: string;
  avatarImage: string;
}

export interface ContextData {
  title: string;
  intro: string;
  description: string;
  image: string;
  video: string;
}

export const messagesState = atom<Message[]>({
  key: 'messages',
  default: [],
});

export const defaultChatBot: ChatBotStore = {
  key: ChatBotNotLoaded,
  name: 'Dr. John',
  description:
    'Emotional support, stress, anxiety, depression, and relationship issues',
  avatar: '/images/avatars/av2.png',
  bgImage: '/chat-bg.png',
  backgroundImage: '/chat-bg.png',
  avatarImage: '/images/avatars/av2.png',
  prompt:
    'The following is a conversation between {{userName}} and an AI therapist named {{agentName}}. The therapist is calm, patient and emphatic. his goal is to help {{userName}} feel better and act in positive ways.\n {{prevChatAsText}}\n {{userName}}: {{message}}\n {{agentName}}: ',
  logo: '/parent-coach-logo.png',
  autoTranslate: false,
  autoTranslateTarget: 'en',
  temperature: 0.7,
  ttsLanguage: 'en-US',
  ttsActor: 'en-US-Wavenet-A',
};

export const chatBotsState = atom<ChatBotStore[]>({
  key: 'chatBots',
  default: [],
});

export const getChatBotFromStore = (chatBots: ChatBotStore[], id: string) => {
  return chatBots?.find((chatBot) => chatBot.key === id) || chatBots[0];
};

export const userProfileState = atom<UserProfile>({
  key: 'userProfile',
  default: {
    name: 'Avi',
    avatar: '/images/avatars/av3.png',
    activeChatBot: ChatBotNotLoaded,
    isAudioPlaying: false,
  },
});

export const contextData = atom<ContextData[]>({
  key: 'contextData',
  default: [],
});


components/Avatar.tsx:
export enum AvatarStyles {
  logo = 'h-14 m-0',
  avatar = 'h-10 m-0',
  large = 'h-28 m-0',
}

const Avatar = ({
  imageUrl,
  avatarStyle,
}: {
  imageUrl: string;
  avatarStyle: AvatarStyles;
}) => {
  return <img src={imageUrl} className={`${avatarStyle} rounded-full`} />;
};

export { Avatar };


components/BreadCrumbs.tsx:
import React from 'react';
import { useLocation } from 'react-router-dom';
import { useRootStore } from '../store/common/RootStoreContext';

const capitalizeFirstLetter = (string: string) => {
  return string && string.charAt(0).toUpperCase() + string.slice(1);
};

const BreadCrumbs: React.FC = () => {
  
  const location = useLocation();
  const rootStore = useRootStore();
  const pathParts = location.pathname.split('/');
  const currentPage = pathParts[2];
  const assistantId = pathParts[3];
  const assistant = assistantId ? rootStore.getAssistantById(assistantId) : null;

  return (
    <nav className="w-full rounded-md mb-5">
      <ol className="list-reset flex">
        <li>
          <a
            href="/admin"
            className="text-primary transition duration-150 ease-in-out hover:text-primary-600 focus:text-primary-600 active:text-primary-700 dark:text-primary-400 dark:hover:text-primary-500 dark:focus:text-primary-500 dark:active:text-primary-600"
          >
            Home
          </a>
        </li>
        <li>
          <span className="mx-2 text-neutral-500 dark:text-neutral-400">/</span>
        </li>
        <li className="text-neutral-500 dark:text-neutral-400">
          {capitalizeFirstLetter(currentPage)}
        </li>
        {assistant && (
          <>
            <li>
              <span className="mx-2 text-neutral-500 dark:text-neutral-400">/</span>
            </li>
            <li className="text-neutral-500 dark:text-neutral-400">
              {assistant.name}
            </li>
          </>
        )}
      </ol>
    </nav>
  );
};
export { BreadCrumbs };


components/ChatMessage.tsx:
import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useRecoilState, useRecoilValue } from 'recoil';
import { observer } from 'mobx-react-lite';
import { Message, SenderType } from '../atoms/dataStore-old';
import { playAudio } from '../services/AudioService';
import { Avatar, AvatarStyles } from './Avatar';
import { useRootStore } from '../store/common/RootStoreContext';
import { IconButton } from './admin/IconButton';
import {
  InformationCircleIcon,
  MegaphoneIcon,
  ShieldCheckIcon,
  StarIcon,
  XCircleIcon,
} from '@heroicons/react/24/outline';
import { CheckIcon } from '@heroicons/react/24/solid';

interface ChatMessageProps {
  message: Message;
  autoTranslate?: boolean;
  onUserSelection?: (selection: string) => void;
  onDeleteMessage?: () => void;
}

interface MessageTextProps {
  text: string;
}

const MessageText: React.FC<MessageTextProps> = ({ text }) => {
  return <div className="mb-2">{text}</div>;
};

const MessageInfo: React.FC<MessageTextProps> = ({ text }) => {
  return (
    <div className="flex flex-col items-center">
      <div className=" bg-sky-200 rounded-full p-3 h-12 w-12 mb-2.5">
        <InformationCircleIcon className="text-sm mb-1 text-slate-600" />
      </div>
      <div className="mb-3">{text}</div>
    </div>
  );
};

const MessageSection: React.FC<MessageTextProps> = ({ text }) => {
  return (
    <div className="flex flex-col items-center">
      <div className="  bg-slate-100 rounded-full p-1 h-6 w-6 mb-2.5">
        <StarIcon className="text-sm mb-1 text-slate-600" />
      </div>
      <div className="mb-3">{text}</div>
    </div>
  );
};

const MessageSuccess: React.FC<MessageTextProps> = ({ text }) => {
  return (
    <div className="flex flex-col items-center">
      <div className="  bg-lime-200 rounded-full p-3 h-12 w-12 mb-2.5">
        <CheckIcon className="text-sm mb-1 text-slate-600" />
      </div>
      <div className="mb-3">{text}</div>
    </div>
  );
};

const MessageCallout: React.FC<MessageTextProps> = ({ text }) => {
  return (
    <div className="flex flex-col items-center">
      <div className=" bg-fuchsia-200 rounded-full p-3 h-12 w-12 mb-2.5">
        <MegaphoneIcon className=" text-sm mb-1 text-slate-600" />
      </div>
      <div className="mb-3">{text}</div>
    </div>
  );
};

interface MessageOptionsProps {
  options: [any];
  onOptionClick?: (option: any) => void;
}

const MessageOptions: React.FC<MessageOptionsProps> = ({
  options,
  onOptionClick,
}) => {
  const handleClick = (selection: string) => {
    if (onOptionClick) {
      onOptionClick(selection);
    }
  };

  return (
    <div className="w-full mt-4  ">
      <div className="flex flex-wrap ">
        {options.map((option, index) => (
          <div key={option.text} className=" mb-3">
            <div
              className="bg-white hover:bg-slate-100 rounded-xl flex flex-col  justify-center h-full "
              onClick={() => handleClick(option.text || option)}
            >
              {option.image && (
                <img
                  src={option.image}
                  alt={option.text || option}
                  className="rounded-xl"
                />
              )}

              <div className="flex flex-col items-center">
                <button
                  key={index}
                  className={`text-slate-600 ${
                    option.image ? 'self-start my-2' : ' my-2'
                  }`}
                >
                  {option.text || option}
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

const renderContent = (
  content: any[],
  onUserSelection?: (selection: string) => void,
) => {
  console.log(content);

  return content?.map((item, index) => {
    switch (item.type) {
      case 'text':
        return <MessageText key={index} text={item.text} />;
      case 'options':
        return (
          <MessageOptions
            key={index}
            options={item.options}
            onOptionClick={onUserSelection} // Pass onUserSelection as the onOptionClick callback
          />
        );
      case 'video':
        return (
          <video
            key={index}
            src={item.video_url}
            controls
            className="w-full my-2"
          />
        );

      case 'text-info':
        return <MessageInfo key={index} text={item.text} />;
      case 'text-success':
        return <MessageSuccess key={index} text={item.text} />;
      case 'text-callout':
        return <MessageCallout key={index} text={item.text} />;
      case 'text-section':
        return <MessageSection key={index} text={item.text} />;

      default:
        return null;
    }
  });
};

const ChatMessageStyles = {
  user: {
    container: 'col-start-1 col-end-12 p-1 rounded-lg',
    flexRow: 'flex flex-row items-center',
    message: 'relative ml-3 text-sm bg-white py-4 px-4 shadow rounded-lg',
  },
  bot: {
    container: 'col-start-2 col-end-13 p-3 rounded-lg',
    flexRow: 'flex items-center justify-start flex-row-reverse',
    message: 'relative mr-3 text-sm bg-indigo-100 py-4 px-4 shadow rounded-lg',
  },
};

const ChatMessage: React.FC<ChatMessageProps> = observer(
  ({ message, onUserSelection, onDeleteMessage }) => {
    const { activeChatbot, userProfile } = useRootStore();

    const messageStyles =
      message.role === SenderType.user
        ? ChatMessageStyles.user
        : ChatMessageStyles.bot;
    const avatarImage =
      message.role === SenderType.user
        ? userProfile?.avatar
        : activeChatbot?.avatarImage;

    return (
      <>
        <div
          className={messageStyles.container}
          // onClick={() => playAudio(message.audio)}
        >
          <div className={messageStyles.flexRow}>
            <Avatar
              imageUrl={avatarImage || '/images/avatars/av1.png'}
              avatarStyle={AvatarStyles.avatar}
            />
            <div
              className={messageStyles.message}
              // style={{
              //   direction:
              //     chatBot &&
              //     chatBot.autoTranslate &&
              //     chatBot.autoTranslateTarget === "he"
              //       ? "rtl"
              //       : "ltr",
              // }}
            >
              {/* <div>{sanitizeMessageText(getMessageText(message))}</div> */}
              {/* <div>{message.content}</div> */}
              {/* <div>{renderContent(message.content)}</div> */}
              <div>{renderContent(message.content, onUserSelection)}</div>{' '}
              {/* Pass onUserSelection to renderContent */}
            </div>
            <div>
              <IconButton
                icon={<XCircleIcon className="w-5 h-5 text-slate-100 m-3" />}
                onClick={onDeleteMessage || (() => {})}
              />
            </div>
          </div>
        </div>
      </>
    );
  },
);

export { ChatMessage, ChatMessageStyles };


components/ChatMessageWelcome.tsx:
import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { Avatar, AvatarStyles } from './Avatar';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../store/common/RootStoreContext';

interface ChatMessageProps {
  enabled: boolean;
  onClickStartChat?: () => void;
}

const ChatMessageWelcome: React.FC<ChatMessageProps> = observer(
  ({ onClickStartChat, enabled }) => {
    const { activeChatbot, userProfile } = useRootStore();

    useEffect(() => {
      console.log('activeChatbot', activeChatbot?.key);
    }, [activeChatbot]);

    // useEffect(() => {
    //   fetch(`http://127.0.0.1:5000/chat_sessions/${sessionId}`)
    //     .then((response) => response.json())
    //     .then((data) => {
    //       if (data.chatbot) {
    //         setChatBot(data.chatbot);
    //       }
    //     });
    // }, [sessionId]);

    const handleStartChat = () => {
      onClickStartChat && onClickStartChat();
    };

    return (
      <>
        <div className="col-start-2 col-end-12 mt-8 mb-8">
          <div
            className="flex flex-col items-center bg-white p-5 shadow rounded-xl space-y-4"
            // style={{
            //   direction:
            //     chatBot &&
            //     chatBot.autoTranslate &&
            //     chatBot.autoTranslateTarget === "he"
            //       ? "rtl"
            //       : "ltr",
            // }}
          >
            <Avatar
              imageUrl={activeChatbot?.avatarImage || ''}
              avatarStyle={AvatarStyles.large}
            />
            <div>{activeChatbot?.description}</div>
            {!enabled ? null : (
              <button
                className="bg-stone-300 p-4 rounded-xl w-full"
                onClick={handleStartChat}
              >
                Start Chat
              </button>
            )}
          </div>
        </div>
      </>
    );
  },
);

export { ChatMessageWelcome };


components/ChatRouteLoader.tsx:
import { ReactNode, useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useRootStore } from '../store/common/RootStoreContext';
import { observer } from 'mobx-react-lite';
import { autorun } from 'mobx';

interface ChatRouteLoaderProps {
  children: ReactNode;
}

export const ChatRouteLoader: React.FC<ChatRouteLoaderProps> = observer(
  ({ children }) => {
    const [loading, setLoading] = useState<boolean>(true);
    const { sessionId } = useParams<{ sessionId: string }>();
    const rootStore = useRootStore();

    useEffect(() => {
      autorun(() => {
        if (
          !rootStore.chatSessionsLoaded ||
          !rootStore.chatbotsLoaded ||
          !sessionId
        )
          return;

        rootStore.setActiveChatSession(sessionId);
        rootStore.setActiveChatbot(
          rootStore.selectedChatSession?.chatbot_key || '',
        );

        setLoading(false);
      });
    }, [
      rootStore.chatSessionsLoaded,
      rootStore.chatbotsLoaded,
      sessionId,
      rootStore.selectedChatSession,
    ]);

    if (loading) return <> loading ... </>;
    return <>{children}</>;
  },
);


components/ContainerBGImage.tsx:
interface ContainerBGImageProps {
  bgImage: string;
  children: React.ReactNode;
}

const ContainerBGImage = ({ bgImage, children }: ContainerBGImageProps) => {
  return (
    <div
      className="flex flex-row h-full w-full overflow-x-hidden"
      style={{
        backgroundImage: `linear-gradient(rgba(200, 200, 200, 0.6), rgba(200, 200, 200, 0.6)), url(${bgImage})`,
        backgroundSize: 'cover',
      }}
    >
      {children}
    </div>
  );
};

export { ContainerBGImage };


components/ContentContainer.tsx:
import React from 'react';

interface ContentContainerProps {
  children: React.ReactNode;
  className?: string; // Add an optional className prop
}

const ContentContainer: React.FC<ContentContainerProps> = ({
  children,
  className,
}) => {
  // Set a default value for the className prop, then add any additional classes from the passed-in className
  const defaultClasses = 'flex-1 overflow-y-scroll antialiased';
  const mergedClasses = className
    ? `${defaultClasses} ${className}`
    : defaultClasses;

  return <main className={mergedClasses}>{children}</main>;
};

export { ContentContainer };


components/ContentPageContainer.tsx:
interface ContentPageContainerProps {
  children: React.ReactNode;
}

const ContentPageContainer: React.FC<ContentPageContainerProps> = ({
  children,
}) => {
  return <main className="p-5">{children}</main>;
};

export { ContentPageContainer };


components/CustomDropdown.tsx:
import { BoltIcon } from '@heroicons/react/24/solid';
import React, { useState } from 'react';

type DropdownOption = {
  value: string | number;
  label: string;
  description?: string;
};

interface CustomDropdownProps {
  options: DropdownOption[];
  onSelect: (option: DropdownOption) => void;
}

export const CustomDropdown: React.FC<CustomDropdownProps> = ({
  options,
  onSelect,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedOption, setSelectedOption] = useState<DropdownOption | null>(
    null
  );
  const toggleDropdown = () => {
    if (options.length > 0) {
      setIsOpen(!isOpen);
    }
  };


  const handleSelect = (option: DropdownOption) => {
    setSelectedOption(null); // Reset selectedOption after selection
    onSelect(option);
    setIsOpen(false);
  };
  const displayText = selectedOption
    ? selectedOption.label
    : options.length > 0
    ? 'select action'
    : 'no available actions';

  const arrowStyle = {
    transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
    transition: 'transform 0.3s ease',
  };

  return (
    <div className="relative">
      <div
        className="cursor-pointer border p-2 rounded flex justify-between items-center"
        onClick={toggleDropdown} // Use the toggleDropdown function
      >
        <span>{displayText}</span>
        <svg
          style={arrowStyle}
          xmlns="http://www.w3.org/2000/svg"
          className="h-4 w-4"
          viewBox="0 0 20 20"
          fill="currentColor"
        >
          <path
            fillRule="evenodd"
            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
            clipRule="evenodd"
          />
        </svg>
      </div>

      {isOpen && options.length > 0 && ( // Ensure options are available before rendering dropdown
        <div className="absolute border rounded  bg-zinc-50 z-10 mt-0.5 w-full flex flex-col space-y-1">
          {options.map((option) => (
            <div
              key={option.value}
              className="p-3 hover:bg-gray-100 cursor-pointer text-base"
              onClick={() => handleSelect(option)}
            >
              <div className="flex flex-row items-start space-x-2">
                <BoltIcon className="w-4 h-4 mt-1 flex-shrink-0 text-indigo-300" />
                <div className="flex flex-col">
                  <div className="text-zinc-800">{option.label}</div>
                  <div className="text-sm text-zinc-500">
                    {option.description || 'Description'}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};


components/DynamicForm.tsx:
import React, { useEffect, useState } from 'react';
import InputWithLabel from './admin/InputWithLabel';
import { TextareaWithLabel } from './admin/TextareaWithLabel';
import { KeyValue, KeyValueList } from './KeyValueList';
import LoadingButton from './core/LoadingButton';
import { AssistantKeys } from '../store/models/Assistant';
import { CompanyKeys } from '../store/models/Company';
import { UserKeys } from '../store/models/User';

export type FieldType = 'input' | 'textarea' | 'key-value-list';
export type FormType = 'create' | 'update';

export interface FieldVisibility {
  create: boolean;
  view: boolean;
  update: boolean;
}

export interface BaseFieldConfig {
  id: string;
  key: AssistantKeys | CompanyKeys | UserKeys;
  type: FieldType;
  label: string;
  visibility: FieldVisibility;
}

export interface InputFieldConfig extends BaseFieldConfig {
  type: 'input';
  value: string;
}

export interface TextareaFieldConfig extends BaseFieldConfig {
  type: 'textarea';
  value: string;
}

export interface KeyValueListFieldConfig extends BaseFieldConfig {
  type: 'key-value-list';
  value: KeyValue[];
}

export type FieldConfig =
  | InputFieldConfig
  | TextareaFieldConfig
  | KeyValueListFieldConfig;

export interface FormValues extends Record<string, string | KeyValue[]> {}

export interface DynamicFormProps {
  fields: FieldConfig[];
  onSubmit: (values: FormValues) => void;
  isLoading?: boolean;
  formType: FormType;
}

const DynamicForm: React.FC<DynamicFormProps> = ({
  fields,
  onSubmit,
  isLoading,
  formType,
}) => {
  const [filteredFields, setFilteredFields] = useState<FieldConfig[]>([]);
  const [values, setValues] = useState<FormValues>({});

  useEffect(() => {

    const newFilteredFields =
      formType === 'create'
        ? fields.filter((field) => field.visibility?.create === true)
        : fields;
    setFilteredFields(newFilteredFields);

    const initialValues: FormValues = {};
    newFilteredFields.forEach((field) => {
      initialValues[field.id] = field.value;
    });

    setValues(initialValues);
    
  }, [fields, formType]);

  const handleChange = (id: string, newValue: string | KeyValue[]) => {
    setValues((prevValues) => ({ ...prevValues, [id]: newValue }));
  };

  const handleSubmit = () => {
    onSubmit(values);
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        handleSubmit();
      }}
    >
      {filteredFields.map((field) => {
        switch (field.type) {
          case 'textarea':
            return (
              <TextareaWithLabel
                key={field.id}
                label={field.label}
                id={field.id}
                value={values[field.id] as string}
                onChange={(newValue) => handleChange(field.id, newValue)}
              />
            );
          case 'key-value-list':
            return (
              <KeyValueList
                key={field.id}
                title="Identifiers"
                description="Identifiers are used to connect assistant to external sources"
                initialData={(values[field.id] as KeyValue[]) || []}
                onDataChange={(newValue) => handleChange(field.id, newValue)}
              />
            );
          default:
            return (
              <InputWithLabel
                key={field.id}
                type="text"
                label={field.label}
                id={field.id}
                value={values[field.id] as string}
                onChange={(newValue) => handleChange(field.id, newValue)}
              />
            );
        }
      })}

      <LoadingButton
        additionalClassName="mt-2"
        type="submit"
        isLoading={isLoading || false}
      >
        Save Changes
      </LoadingButton>
    </form>
  );
};

export { DynamicForm };


components/Header.tsx:
import { Bars2Icon, TrashIcon } from '@heroicons/react/24/solid';
import { Avatar, AvatarStyles } from './Avatar';
import { useRecoilValue } from 'recoil';
import { useEffect, useState } from 'react';
import { translateText } from '../services/TranslationService';
import { clearSession } from '../services/ChatService';
import { useParams, useLocation } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../store/common/RootStoreContext';

interface HeaderProps {
  onMenuClick: () => void;
  forceShow?: boolean;
}

const Header: React.FC<HeaderProps> = observer(({ onMenuClick, forceShow }) => {
  const location = useLocation();
  const isAdminRoute = location.pathname.startsWith('/admin');

  const { activeChatbot, selectedChatSession } = useRootStore();

  const handleClearChat = async () => {
    if (selectedChatSession?._id) {
      await clearSession(selectedChatSession._id);
      window.location.reload();
    } else {
      console.error('sessionId is undefined');
    }
  };

  // useEffect(() => {
  //   if (!chatBot) {
  //     return;
  //   }

  //   setChatBotAvatar(chatBot.avatarImage);

  //   if (chatBot.autoTranslate) {
  //     translateText(chatBot.name, chatBot.autoTranslateTarget).then(
  //       (translatedText) => {
  //         setChatBotName(translatedText);
  //       }
  //     );

  //     translateText(chatBot.description, chatBot.autoTranslateTarget).then(
  //       (translatedText) => {
  //         setChatBotDescription(translatedText);
  //       }
  //     );
  //   } else {
  //     setChatBotName(chatBot.name);
  //     setChatBotDescription(chatBot.description);
  //   }
  // }, [chatBot]);

  return (
    <>
      {(!isAdminRoute || forceShow) && (
        <header className="p-4 flex justify-between items-center">
          <div
            className="p-1 rounded-2xl bg-gray-200 hover:bg-gray-200 w-9 h-9 cursor-pointer flex items-center justify-center"
            onClick={onMenuClick}
          >
            <Bars2Icon className="h-5 w-5 text-slate-700" />
          </div>
          <div className="headerImageAndText flex flex-row items-center w-full text-left pl-5">
            <Avatar
              imageUrl={activeChatbot?.avatarImage || ''}
              avatarStyle={AvatarStyles.logo}
            />
            <div className="ml-3">
              <div className="text-2xl font-normal">{activeChatbot?.name}</div>
              <div className="text-xs font-light">
                {activeChatbot?.description}
              </div>
            </div>
          </div>

          <div className="mr-3 cursor-pointer">
            <TrashIcon
              className="h-6 w-6  text-yellow-700"
              onClick={handleClearChat}
            />
          </div>
        </header>
      )}
    </>
  );
});

export { Header };


components/Input.tsx:
import React from 'react';

interface Input {
  id: string;
  value: string;
  onChange: (value: string) => void;
  onFocus?: () => void;
  onBlur?: () => void;
  autoFocus?: boolean;
}

const Input: React.FC<Input> = ({
  id,
  value,
  onChange,
  onFocus,
  onBlur,
  autoFocus,
}) => {
  return (
    <div className="w-full">
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onFocus={onFocus}
        onBlur={onBlur}
        autoFocus={autoFocus}
        className="w-full text-sm h-9 p-3 block rounded-md border-0  text-gray-900 ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 "
        id={id}
      />
    </div>
  );
};

export { Input };


components/InputTags.tsx:
import React, { useState } from 'react';
import { TagInput } from './TagInput';
import { CustomDropdown } from './CustomDropdown';

export interface TagType {
  id: string | number;
  name: string;
}

export interface TagsInputProps {
  selectedTags?: TagType[];
  availableTags: TagType[];
  title: string;
  description: string;
}

const TagsInput: React.FC<TagsInputProps> = ({
  selectedTags = [],
  availableTags,
  title,
  description,
}) => {
  const [tags, setTags] = useState<TagType[]>(selectedTags);
  const noTagsText = tags.length === 0 ? 'no action selected' : null;

  const removeTag = (tagToRemove: string) => {
    setTags(tags.filter((tag) => tag.name !== tagToRemove));
  };

  const addTag = (tagToAdd: TagType) => {
    if (!tags.find((tag) => tag.id === tagToAdd.id)) {
      setTags([...tags, tagToAdd]);
    }
  };

  const handleSelectTag = (option: {
    value: string | number;
    label: string;
  }) => {
    // Create a TagType object from the selected DropdownOption
    const tagToAdd: TagType = { id: option.value, name: option.label };
    addTag(tagToAdd);
  };

  // Filter out tags that are already selected
  const filteredAvailableTags = availableTags.filter(
    (availableTag) =>
      !tags.find((selectedTag) => selectedTag.id === availableTag.id)
  );

  return (
    <>
      <div className="mb-2">
        <h2 className="text-xl">{title}</h2>
        <p className="mb-2 text-sm">{description}</p>
      </div>
      <div className="rounded border border-solid border-neutral-300 bg-transparent bg-clip-padding px-3 py-3 text-base font-normal leading-tight text-neutral-700 transition duration-200 ease-linear placeholder:text-transparent focus:border-primary focus:pb-[0.625rem] focus:pt-[1.625rem] focus:text-neutral-700 focus:outline-none peer-focus:text-primary dark:border-neutral-600 dark:text-neutral-200 dark:focus:border-primary dark:peer-focus:text-primary flex-col space-y-2 ">
        <div>
          {noTagsText ||
            tags.map((tag) => (
              <TagInput key={tag.id} title={tag.name} onRemove={removeTag} />
            ))}
        </div>

        <div>
          <CustomDropdown
            options={filteredAvailableTags.map((tag) => ({
              value: tag.id,
              label: tag.name,
            }))}
            onSelect={handleSelectTag}
          />
        </div>
      </div>
    </>
  );
};

export { TagsInput };


components/KeyValueList.tsx:
import React, { useEffect, useState } from 'react';
import { Input } from './Input';
import { IconButton } from './admin/IconButton';
import {
  ArrowUturnLeftIcon,
  MinusCircleIcon,
  PlusCircleIcon,
} from '@heroicons/react/24/outline';
import _ from 'lodash';

export interface KeyValue {
  key: string;
  value: string;
}

interface KeyValueListProps {
  title: string;
  description: string;
  initialData: KeyValue[];
  onDataChange: (data: KeyValue[]) => void;
}

const KeyValueList: React.FC<KeyValueListProps> = ({
  title,
  description,
  initialData,
  onDataChange,
}) => {

  const [keyValueData, setKeyValueData] = useState<KeyValue[]>([]);
  const [initialKeyValueData, setInitialKeyValueData] = useState<KeyValue[]>([]);

  useEffect(() => {
    setKeyValueData(_.cloneDeep(initialData));
    if (initialKeyValueData.length === 0) {
      setInitialKeyValueData(_.cloneDeep(initialData));
    }
  }, [initialData]);

  const resetToInitialData = () => {
    setKeyValueData(_.cloneDeep(initialKeyValueData));
    onDataChange(initialKeyValueData);
  };


  const handleKeyChange = (newValue: string, index: number) => {
    const updatedData = [...keyValueData];
    updatedData[index].key = newValue;
    setKeyValueData(updatedData);
    onDataChange(keyValueData);
  };

  const handleValueChange = (newValue: string, index: number) => {
    const updatedData = [...keyValueData];
    updatedData[index].value = newValue;
    setKeyValueData(updatedData);
    onDataChange(keyValueData);
  };

  const addParam = () => {
    setKeyValueData([...keyValueData, { key: '', value: '' }]);
  };

  const removeParam = (index: number) => {
    const updatedData = [...keyValueData];
    updatedData.splice(index, 1);
    setKeyValueData(updatedData);
    onDataChange(updatedData);
  };


  return (
    <div>
      <div className="flex justify-between items-center mt-4">
        <h2 className="text-xl">{title}</h2>
        <div className="space-x-2">
          <IconButton
            icon={<ArrowUturnLeftIcon className="w-6 h-6  text-green-800" />}
            onClick={resetToInitialData}
          />
          <IconButton
            icon={<PlusCircleIcon className="w-6 h-6 text-stone-400" />}
            onClick={addParam}
          />
        </div>
      </div>
      <p className="mb-2 text-sm">{description}</p>
      {keyValueData.map(({ key, value }, index) => (
        <div key={index} className="flex items-center space-x-2 mb-2">
          <Input
            id={`key_${index}`}
            value={key}
            onChange={(newValue) => handleKeyChange(newValue, index)}
          />
          <Input
            id={`value_${index}`}
            value={value}
            onChange={(newValue) => handleValueChange(newValue, index)}
          />
          <IconButton
            icon={<MinusCircleIcon className="w-6 h-6 text-orange-400" />}
            onClick={() => removeParam(index)}
          />
        </div>
      ))}
    </div>
  );
};

export { KeyValueList };


components/SideMenu.tsx:
import React, { SVGProps, useEffect, useState } from 'react';
import {
  ChatBubbleBottomCenterTextIcon,
  AcademicCapIcon,
  UsersIcon,
  Cog8ToothIcon,
} from '@heroicons/react/24/solid';
import { observer } from 'mobx-react-lite';
import { XMarkIcon } from '@heroicons/react/24/outline';
import { useRootStore } from '../store/common/RootStoreContext';

interface SideMenuProps {
  isOpen: boolean;
  closeMenu: () => void;
}

interface SideMenuItemProps {
  icon: React.FC<SVGProps<SVGSVGElement>>;
  text: string;
  onClick?: () => void;
}

const SideMenuItem: React.FC<SideMenuItemProps> = ({
  icon: Icon,
  text,
  onClick,
}) => (
  <div className="hover:bg-slate-300 h-12 cursor-pointer" onClick={onClick}>
    <div className="flex mb-4 p-5">
      <Icon className="h-4 w-4 text-gray-500 mr-3 mt-0.5" />
      <li className="mb-2">{text}</li>
    </div>
  </div>
);

const SideMenu: React.FC<SideMenuProps> = observer(({ isOpen, closeMenu }) => {
  const { activeChatbot } = useRootStore();

  return (
    <aside
      className={`fixed z-10 inset-0  bg-orange-100 transform transition-all w-60 p-0 ${
        isOpen ? 'translate-x-0' : '-translate-x-full'
      } duration-300`}
    >
      <header className="flex items-center justify-between p-4 mt-4">
        <img
          src={activeChatbot?.avatarImage}
          className="w-[8rem] object-contain"
        />
        <button className="p-1 rounded-full hover:text-gray-400 w-10 h-10">
          <XMarkIcon className="h-6 w-6 text-slate-400" />
        </button>
      </header>

      <nav className="p-0">
        <ul className="font-light">
          <SideMenuItem icon={AcademicCapIcon} text="Grow" />
          <SideMenuItem icon={ChatBubbleBottomCenterTextIcon} text="Share" />
          <SideMenuItem icon={UsersIcon} text="Therapists" />
          <SideMenuItem icon={Cog8ToothIcon} text="Profile" />
        </ul>
      </nav>
    </aside>
  );
});

export { SideMenu };


components/Table.tsx:
import React from 'react';

interface TableProps {
  headers: string[];
  data: { [key: string]: any }[];
  onRowClick?: (row: any) => void;
  Actions?: (row: any) => JSX.Element; // Add this line
}

const Table: React.FC<TableProps> = ({
  headers,
  data,
  onRowClick,
  Actions,
}) => {
  const renderCellContent = (value: any) => {
    if (typeof value === 'boolean') {
      return value.toString();
    }
    return value;
  };

  return (
    <div className="flex flex-col w-full">
      <div className="overflow-x-auto sm:-mx-6 lg:-mx-8">
        <div className="inline-block min-w-full py-2 sm:px-6 lg:px-8">
          <div className="overflow-hidden">
            <table className="min-w-full text-left text-sm font-light">
              <thead className="border-b font-medium dark:border-neutral-500">
                <tr>
                  {headers.map((row, index) => (
                    <th
                      key={index}
                      scope="col"
                      className="px-6 py-4 max-w-xs truncate"
                    >
                      {row}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {data.map((row, rowIndex) => (
                  <tr
                    key={rowIndex}
                    className="border-b dark:border-neutral-500 transition duration-300 ease-in-out hover:bg-neutral-100 dark:hover:bg-neutral-600"
                    onClick={() => onRowClick?.(row)}
                  >
                    {headers.map((header, headerIndex) => (
                      <td
                        key={headerIndex}
                        className={`px-6 py-4 truncate ${
                          header === 'specificColumn' ? 'max-w-md' : 'max-w-xs'
                        }`}
                      >
                        {renderCellContent(row[header])}
                      </td>
                    ))}
                    {Actions && <td className="px-6 py-4">{Actions(row)}</td>}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
};

export { Table };


components/Tabs.tsx:
import React, { ReactNode, useEffect } from 'react';
import { Tab, initTE } from 'tw-elements';

interface TabItem {
  id: string;
  label: string;
  content: ReactNode;
}

interface TabsProps {
  tabs: TabItem[];
}

const Tabs: React.FC<TabsProps> = ({ tabs }) => {
  useEffect(() => {
    initTE({ Tab });
  }, []);

  return (
    <>
      <ul
        className="mb-5 flex list-none flex-row flex-wrap border-b-0 pl-0"
        role="tablist"
        data-te-nav-ref
      >
        {tabs.map((tab, index) => (
          <li role="presentation" key={tab.id}>
            <a
              href={`#${tab.id}`}
              className="my-2 block border-x-0 border-b-2 border-t-0 border-transparent px-3 mr-2 pb-2 pt-2 text-xs font-medium uppercase leading-tight text-neutral-500 hover:isolate hover:border-transparent hover:bg-neutral-100 focus:isolate focus:border-transparent data-[te-nav-active]:border-primary data-[te-nav-active]:text-primary dark:text-neutral-400 dark:hover:bg-transparent dark:data-[te-nav-active]:border-primary-400 dark:data-[te-nav-active]:text-primary-400"
              data-te-toggle="pill"
              data-te-target={`#${tab.id}`}
              role="tab"
              aria-controls={tab.id}
              aria-selected={index === 0 ? 'true' : 'false'}
              {...(index === 0 && { 'data-te-nav-active': true })}
            >
              {tab.label}
            </a>
          </li>
        ))}
      </ul>

      <div className="mb-6">
        {tabs.map((tab, index) => (
          <div
            key={tab.id}
            className={`hidden opacity-${
              index === 0 ? '100' : '0'
            } transition-opacity duration-150 ease-linear data-[te-tab-active]:block`}
            id={tab.id}
            role="tabpanel"
            aria-labelledby={`${tab.id}-tab`}
            {...(index === 0 && { 'data-te-tab-active': true })}
          >
            {tab.content}
          </div>
        ))}
      </div>
    </>
  );
};

export { Tabs };


components/TagInput.tsx:
import React from 'react';
import { IconButton } from './admin/IconButton';
import { BeakerIcon, XMarkIcon } from '@heroicons/react/24/solid';

interface TagInputProps {
  title: string;
  onRemove: (title: string) => void;
}

const TagInput: React.FC<TagInputProps> = ({ title, onRemove }) => {
  return (
    <span className="tag inline-flex items-center bg-primary-100  text-slate-700  mr-2.5 px-3 py-2 rounded-2xl">
      {title}
      <IconButton
        icon={<XMarkIcon className="ml-5 w-4 h-4 text-stone-900" />}
        onClick={() => onRemove(title)}
      />
      <IconButton
        icon={<BeakerIcon className="ml-1 w-4 h-4 text-stone-900" />}
        onClick={() => onRemove(title)}
      />
    </span>
  );
};

export { TagInput };


components/admin/ActionsView/ActionsView.tsx:
import { useCallback, useEffect, useMemo, useState } from 'react';
import React, { memo } from 'react';
import ReactFlow, {
  useNodesState,
  useEdgesState,
  addEdge,
  Controls,
  MiniMap,
  Background,
  BackgroundVariant,
  useReactFlow,
} from 'reactflow';

import 'reactflow/dist/style.css';
import { CustomNode } from './custom-nodes/CustomNodeChatbot';
import { CustomNodeState } from './custom-nodes/CustomNodeState';
import { CustomNodeProcessor } from './custom-nodes/CustomNodeProcessor';
import { Chatbot } from '../../../services/ChatbotService';
import { IChatSession } from '../../../store/models/ChatSession';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../../store/common/RootStoreContext';
import { autorun } from 'mobx';

interface ActionsViewProps {
  chatbot: Chatbot;
  onNodeSelected: (node: any, type: string) => void;
}

const ActionsView: React.FC<ActionsViewProps> = observer(
  ({ chatbot, onNodeSelected }) => {
    const rootStore = useRootStore();
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges] = useState<any[]>([]);
    const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);

    const onConnect = useCallback(
      (params: any) => setEdges((eds) => addEdge(params, eds)),
      [setEdges],
    );

    const onNodeClick = (event: any, node: any) => {
      setSelectedNodeId(node.id);

      if (node.type === 'custom') {
        onNodeSelected(node.data, 'chatbotNode');
      }
      if (node.type === 'customState') {
        onNodeSelected(node.data, 'stateNode');
      }
      if (node.type === 'customProcessor') {
        onNodeSelected(node.data, 'processorNode');
      }
    };

    const onPaneClick = useCallback(() => {
      setSelectedNodeId(null);
      onNodeSelected(null, '');
    }, [onNodeSelected]);

    const selectedNodeIdMemo = useMemo(() => selectedNodeId, [selectedNodeId]);

    const nodeTypes = useMemo(
      () => ({
        custom: memo((props: any) => (
          <CustomNode {...props} selectedNodeId={selectedNodeIdMemo} />
        )),
        customState: memo((props: any) => (
          <CustomNodeState {...props} selectedNodeId={selectedNodeIdMemo} />
        )),
        customProcessor: memo((props: any) => (
          <CustomNodeProcessor {...props} selectedNodeId={selectedNodeIdMemo} />
        )),
      }),
      [selectedNodeIdMemo],
    );

    const reactFlow = useReactFlow();
    const { setViewport } = reactFlow;

    useEffect(() => {
      setViewport({ x: 0, y: 0, zoom: 0.7 }, { duration: 600 });
    }, [setViewport]);

    useEffect(() => {
      const disposer = autorun(() => {
        const chatbotNode = {
          id: chatbot.name,
          type: 'custom',
          data: {
            name: chatbot.name,
            description: chatbot.description,
            avatarImage: chatbot.avatarImage,
            backgroundImage: chatbot.backgroundImage,
            maxTokens: chatbot.maxTokens,
            key: chatbot.key,
            type: 'chatbotNode',
            selectedNodeId,
          },
          position: { x: (chatbot.states.length * 300) / 2, y: 50 },
        };

        const nodesFromStates = chatbot.states.reduce<any[]>(
          (acc, state, index) => {
            const isActive =
              rootStore.selectedChatSession &&
              rootStore.selectedChatSession.current_state === state.name;
            const stateNode = {
              id: state.name,
              type: 'customState',
              data: {
                _id: state._id,
                name: state.name,
                title: state.title,
                prompt: state.prompt,
                model: state.model,
                temperature: state.temperature,
                type: 'stateNode',
                isActive,
                selectedNodeId,
              },
              position: { x: index * 370 + 450, y: 300 },
            };

            const processorNodes = state.processors.map(
              (processor, processorIndex) => {
                const processorHeight = 400;
                const positionY =
                  600 + (processorHeight + 120) * processorIndex;

                return {
                  id: `${state.name}-${processor._id}`,
                  type: 'customProcessor',
                  data: {
                    _id: processor._id,
                    title: processor.title,
                    processor_name: processor.processor_name,
                    processor_data: processor.processor_data,
                    type: 'processorNode',
                  },
                  position: { x: index * 480 + 495, y: positionY },
                };
              },
            );

            return [...acc, stateNode, ...processorNodes];
          },
          [chatbotNode],
        );

        const initEdges = chatbot.states.flatMap((state) => {
          const stateToChatbotEdge = {
            id: `${chatbot.name}-${state.name}`,
            source: chatbot.name,
            target: state.name,
          };

          const processorEdges = state.processors.map(
            (processor, processorIndex) => {
              if (processorIndex === 0) {
                return {
                  id: `${state.name}-${processor._id}`,
                  source: state.name,
                  target: `${state.name}-${processor._id}`,
                };
              } else {
                const previousProcessor = state.processors[processorIndex - 1];
                return {
                  id: `${previousProcessor._id}-${processor._id}`,
                  source: `${state.name}-${previousProcessor._id}`,
                  target: `${state.name}-${processor._id}`,
                };
              }
            },
          );

          return [stateToChatbotEdge, ...processorEdges];
        });

        setNodes(nodesFromStates);
        setEdges(initEdges);
      });

      return () => disposer();
    }, [chatbot, rootStore]);

    return (
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onNodeClick={onNodeClick}
        onConnect={onConnect}
        onPaneClick={onPaneClick}
        nodeTypes={nodeTypes}
        className="bg-teal-50"
      >
        <Controls />
        <Background variant={BackgroundVariant.Dots} gap={24} size={2} />
      </ReactFlow>
    );
  },
);

export { ActionsView };


components/admin/ActionsView/custom-nodes/CustomNodeChatbot.tsx:
import { useEffect } from 'react';
import ReactFlow, { Handle, Position } from 'reactflow';
import { CalculatorIcon, KeyIcon } from '@heroicons/react/24/outline';
import { LabelText } from '../../../chat/LabelText';

type CustomNodeData = {
  name: string;
  description: string;
  avatarImage: string;
  key: string;
  maxTokens: number;
  image: string;
};

interface CustomNodeProps {
  data: CustomNodeData;
  id: string;
  selectedNodeId: string | null;
}

const CustomNode: React.FC<CustomNodeProps> = ({
  data,
  id,
  selectedNodeId,
}) => {
  const isSelected = id === selectedNodeId;

  useEffect(() => {}, [data]);

  return (
    <div
      className={`p-5 shadow-md rounded-md bg-white border-2 ${
        isSelected ? 'border-red-500' : 'border-stone-400'
      }`}
    >
      <div className="flex">
        <div className="w-32 h-32 flex justify-center items-center bg-gray-100">
          <img src={data.avatarImage} alt="" />
        </div>
        <div className="ml-4">
          <div className="text-lg font-bold">{data.name}</div>
          <div className="text-gray-500">{data.description}</div>

          <div className="flex items-center pt-5">
            <LabelText
              label={<CalculatorIcon className="h-5 w-5 text-slate-400" />}
              text={data.maxTokens}
            />
            <div className="mr-4"></div>
            <LabelText
              label={<KeyIcon className="h-5 w-5 text-slate-400" />}
              text={data.key}
            />
          </div>
        </div>
      </div>

      <Handle
        type="target"
        position={Position.Top}
        className="w-16 !bg-teal-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="w-16 !bg-teal-500"
      />
    </div>
  );
};

export { CustomNode };


components/admin/ActionsView/custom-nodes/CustomNodeProcessor.tsx:
import { Handle, Position } from 'reactflow';
import { CodeBracketIcon } from '@heroicons/react/24/outline';
import { LabelText } from '../../../chat/LabelText';

type CustomNodeProcessorData = {
  title: string;
  processor_name: string;
  processor_data: { [key: string]: any };
};

interface CustomNodeProcessorProps {
  data: CustomNodeProcessorData;
  id: string;
  title: string;
  selectedNodeId: string | null;
}

const CustomNodeProcessor: React.FC<CustomNodeProcessorProps> = ({
  data,
  id,
  title,
  selectedNodeId,
}) => {
  const isSelected = id === selectedNodeId;

  return (
    <div
      className={`shadow-md rounded-md bg-white border-2 ${
        isSelected ? 'border-red-600' : 'border-stone-400'
      }`}
    >
      <div className="p-3 bg-sky-100">
        <LabelText
          label={<CodeBracketIcon className="h-8 w-8 text-slate-400 mr-4" />}
          text={<div className="text-lg font-bold">{data.processor_name}</div>}
          labelVerticalAlign="center"
        />
        <LabelText
          label={<div className="h-8 w-8 text-slate-400 mr-4" />}
          text={<div className="text-base">{data.title}</div>}
          labelVerticalAlign="center"
        />
      </div>

      <div className="ml-1 p-3">
        <LabelText
          label={<div className="h-8 w-8 text-slate-400 mr-2" />}
          text={<div className="text-base">{title}</div>}
        />

        {Object.entries(data.processor_data)
          .slice(0, 6)
          .map(([key, value]) => (
            <div key={key} className="w-96 p-2">
              <LabelText
                label={
                  <div className="text-xs mr-5 text-sky-700 w-44">{key}</div>
                }
                text={
                  <div
                    className={`text-base ${
                      key === 'prompt' ? 'line-clamp-2 h-12' : ''
                    }`}
                  >
                    {value}
                  </div>
                }
                labelVerticalAlign="center"
                layout="vertical"
              />
            </div>
          ))}
      </div>

      <Handle
        type="target"
        position={Position.Top}
        className="w-16 !bg-teal-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="w-16 !bg-teal-500"
      />
    </div>
  );
};

export { CustomNodeProcessor };


components/admin/ActionsView/custom-nodes/CustomNodeState.tsx:
import { Handle, Position } from 'reactflow';
import {
  AcademicCapIcon,
  BeakerIcon,
  BoltIcon,
  DocumentTextIcon,
} from '@heroicons/react/24/outline';
import { LabelText } from '../../../chat/LabelText';
import clsx from 'clsx';

type CustomNodeStateData = {
  name: string;
  title?: string;
  isActive?: boolean;
};

interface CustomNodeStateProps {
  data: CustomNodeStateData;
  id: string;
  selectedNodeId: string | null;
}

const CustomNodeState: React.FC<CustomNodeStateProps> = ({
  data,
  id,
  selectedNodeId,
}) => {
  const isSelected = id === selectedNodeId;
  const bgStyle = clsx('p-4', data.isActive ? 'bg-lime-200' : 'bg-slate-200');

  return (
    <div
      className={`bg-shadow-md rounded-md bg-white border-2 ${
        isSelected ? 'border-red-500' : 'border-stone-400'
      }`}
    >
      <div className={bgStyle}>
        <LabelText
          label={<BoltIcon className="h-8 w-8 text-slate-400 mr-2" />}
          text={<div className="text-lg font-bold">{data.name}</div>}
        />
        <LabelText
          label={<div className="h-8 w-8 text-slate-400 mr-2" />}
          text={<div className="text-base ">{data.title}</div>}
        />
      </div>

      <Handle
        type="target"
        position={Position.Top}
        className="w-16 !bg-teal-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="w-16 !bg-teal-500"
      />
    </div>
  );
};

export { CustomNodeState };


components/admin/DataItem.tsx:
import React from 'react';

interface DataItemProps {
  title: React.ReactNode;
  value: React.ReactNode;
}

const DataItem: React.FC<DataItemProps> = ({ title, value }) => {
  return (
    <div className="flex mb-4">
      <div className="mr-4">{title}</div>
      <div>{value}</div>
    </div>
  );
};

export { DataItem };


components/admin/DialogManager.tsx:
import React, { useState } from 'react';
import { useEventEmitter } from '../../services/mittEmitter';
import {
  EVENT_CLOSE_MODAL,
  EVENT_SHOW_ADD_ASSISTANT_MODAL,
  EVENT_SHOW_ADD_COMPANY_MODAL,
  EVENT_SHOW_ADD_USER_MODAL,
  EventType,
} from '../../utils/eventNames';
import { ModalDialog } from '../core/ModalDialog';
import {
  DialogComponentEventData,
  dialogComponentFactory,
} from '../../services/DialogFactory';

const DialogManager = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [dialogContent, setDialogContent] = useState({
    component: <div>Hello</div>,
    title: 'Default Title',
  });

  const updateContent = (
    eventType: EventType,
    eventData: DialogComponentEventData
  ) => {
    const { component, title } = dialogComponentFactory(eventType, eventData);
    setDialogContent({ component, title });
    setIsOpen(true);
  };

  useEventEmitter(
    EVENT_SHOW_ADD_ASSISTANT_MODAL,
    (eventData: DialogComponentEventData) =>
      updateContent(EVENT_SHOW_ADD_ASSISTANT_MODAL, eventData)
  );

  useEventEmitter(
    EVENT_SHOW_ADD_COMPANY_MODAL,
    (eventData: DialogComponentEventData) =>
      updateContent(EVENT_SHOW_ADD_COMPANY_MODAL, eventData)
  );

  useEventEmitter(EVENT_SHOW_ADD_USER_MODAL,
    (eventData: DialogComponentEventData) =>
      updateContent(EVENT_SHOW_ADD_USER_MODAL, eventData)
  );

  useEventEmitter(EVENT_CLOSE_MODAL, () => setIsOpen(false));

  return (
    <ModalDialog
      title={dialogContent.title}
      isOpen={isOpen}
      onClose={() => setIsOpen(false)}
      onSave={() => {}}
    >
      {dialogContent.component}
    </ModalDialog>
  );
};

export { DialogManager };


components/admin/HOC/withPage.tsx:
import React from 'react';
import { IconButton } from '../IconButton';
import { PlusCircleIcon } from '@heroicons/react/24/outline';

const withPage =
  (title: string, description: string, onAction?: () => void) =>
  (WrappedComponent: React.ComponentType<any>) => {
    const WithPageComponent = (props: any) => {
      return (
        <>
          <div className="flex justify-between items-center">
            <div>
              <h3 className="text-3xl font-bold mb-1">{title}</h3>
              <span className="inline-block whitespace-nowrap rounded-[0.27rem] bg-primary-100 px-[0.65em] pb-[0.25em] pt-[0.35em] text-center align-baseline text-[0.75em] font-bold leading-none text-primary-700">
                {description}
              </span>
            </div>
            <div>
              {onAction && (
                <IconButton
                  icon={<PlusCircleIcon className="w-6 h-6 text-stone-400" />}
                  onClick={onAction}
                  data-te-toggle="modal"
                  data-te-target="#exampleModal"
                />
              )}
            </div>
          </div>
          <hr className="my-4 h-0.5 border-t-0 bg-neutral-100 opacity-100 dark:opacity-50" />
          <WrappedComponent {...props} />
        </>
      );
    };

    WithPageComponent.displayName = `WithPage(${
      WrappedComponent.displayName || WrappedComponent.name || 'Component'
    })`;

    return WithPageComponent;
  };

export { withPage };


components/admin/IconButton.tsx:
import React from 'react';

interface IconButtonProps {
  icon: React.ReactNode;
  onClick: (event?: any) => void;
  className?: string;
}

const IconButton: React.FC<IconButtonProps> = ({
  icon,
  onClick,
  className,
}) => {
  return (
    <button type="button" onClick={onClick} className={className}>
      {icon}
    </button>
  );
};

export { IconButton };


components/admin/InputWithLabel.tsx:
import React from 'react';

interface InputWithLabelProps {
  id: string;
  label: string;
  type: string;
  value: string;
  onChange: (value: string) => void;
  onFocus?: () => void;
  onBlur?: () => void;
  autoFocus?: boolean;
}

const InputWithLabel: React.FC<InputWithLabelProps> = ({
  id,
  label,
  type,
  value,
  onChange,
  onFocus,
  onBlur,
  autoFocus,
}) => {
  return (
    <div className="relative mb-2">
      <input
        type={type}
        value={value || ''}
        onChange={(e) => onChange(e.target.value)}
        onFocus={onFocus}
        onBlur={onBlur}
        autoFocus={autoFocus}
        className="peer m-0 block h-14 w-full rounded border border-solid border-neutral-300 bg-transparent bg-clip-padding px-3 py-4 text-base font-normal leading-tight text-neutral-700 transition duration-200 ease-linear placeholder:text-transparent focus:border-primary focus:pb-[0.625rem] focus:pt-[1.625rem] focus:text-neutral-700 focus:outline-none peer-focus:text-primary dark:border-neutral-600 dark:text-neutral-200 dark:focus:border-primary dark:peer-focus:text-primary [&:not(:placeholder-shown)]:pb-[0.625rem] [&:not(:placeholder-shown)]:pt-[1.625rem]"
        id={id}
        placeholder={label}
      />
      <label
        htmlFor={id}
        className=" text-sm pointer-events-none absolute left-0 top-0 origin-[0_0] border border-solid border-transparent px-3 py-4 text-neutral-500 transition-[opacity,_transform] duration-200 ease-linear peer-focus:-translate-y-2 peer-focus:translate-x-[0.15rem] peer-focus:scale-[0.85] peer-focus:text-primary peer-[:not(:placeholder-shown)]:-translate-y-2 peer-[:not(:placeholder-shown)]:translate-x-[0.15rem] peer-[:not(:placeholder-shown)]:scale-[0.85] motion-reduce:transition-none dark:text-neutral-200 dark:peer-focus:text-primary"
      >
        {label}
      </label>
    </div>
  );
};

export default InputWithLabel;


components/admin/LogItem.tsx:
import React, { useEffect, useState } from 'react';
import {
  ArrowLeftOnRectangleIcon,
  ArrowRightOnRectangleIcon,
} from '@heroicons/react/24/outline';
import { DataItem } from '../../components/admin/DataItem';
import clsx from 'clsx';

interface LogItemProps {
  icon: React.ReactNode;
  name: string;
  title: string;
  input: React.ReactNode;
  output?: React.ReactNode;
  status: string;
  indent?: boolean;
  isDebugLog?: boolean; // New prop
}

const textLimit = (text: string, limit: number) => {
  if (text.length > limit) {
    return text.slice(0, limit) + '...';
  } else {
    return text;
  }
};

const LogItem: React.FC<LogItemProps> = ({
  icon,
  name,
  title,
  input,
  output,
  status,
  indent = false,
  isDebugLog = false, // Default value
}) => {
  const statusClasses = clsx(
    'inline-block whitespace-nowrap rounded-xl p-2 text-center align-baseline text-xs font-bold leading-none',
    {
      'bg-yellow-200  text-gray-600 ': status === 'skip',
      'bg-lime-200 text-gray-600': status === 'success',
      'bg-red-100': status !== 'skip' && status !== 'success',
    },
  );

  const itemBackgroundColor = isDebugLog ? 'bg-pink-100' : 'bg-neutral-50'; // Change background color if isDebugLog is true

  return (
    <li>
      <div className="flex-start flex">
        <div className="-ml-[11px] flex h-[25px] w-[25px] items-center justify-center rounded-full bg-info-100 text-info-700">
          {icon}
        </div>

        {indent && (
          <div className="mt-3 ml-1 w-5 border-t border-indigo-200"></div>
        )}

        <div
          className={`flex-1 mb-4 ml-4 block max-w-md rounded-lg ${itemBackgroundColor} p-4 shadow-md shadow-black/5 dark:bg-neutral-700 dark:shadow-black/10`}
        >
          <div className="flex space-x-2 mb-2">
            <div className="inline-block whitespace-nowrap rounded-full bg-orange-100 p-2 text-center align-baseline text-[0.75em] font-bold leading-none text-gray-600 ">
              <ol className="list-reset flex">
                <li>{name}</li>
                {title && (
                  <>
                    <li>
                      <span className="mx-1 text-neutral-500 dark:text-neutral-400">
                        /
                      </span>
                    </li>
                    <li>{textLimit(title, 15)}</li>
                  </>
                )}
              </ol>
            </div>

            <span className={statusClasses}>
              {typeof status === 'boolean'
                ? status
                  ? 'Success'
                  : 'Failure'
                : status}
            </span>
          </div>

          <div className="mb-2 text-neutral-700 dark:text-neutral-200">
            <DataItem
              title={<ArrowLeftOnRectangleIcon className="w-5 h-5" />}
              value={<div className="text-sm">{input}</div>}
            />
            {output && (
              <DataItem
                title={<ArrowRightOnRectangleIcon className="w-5 h-5" />}
                value={<div className="text-sm">{output}</div>}
              />
            )}
          </div>
        </div>
      </div>
    </li>
  );
};

export { LogItem };


components/admin/Menu.tsx:
import React from 'react';
import logo from '../../assets/l3.png';
import { useLocation } from 'react-router-dom';
import { observer } from 'mobx-react';
import { SessionView } from './SessionView';

export const Menu = observer(() => {
  const menuItems = [
    {
      name: 'Home',
      link: '/admin',
    },
    {
      name: 'Companies',
      link: '/admin/companies',
    },
    {
      name: 'Assistants',
      link: '/admin/assistants',
    },
    {
      name: 'Users',
      link: '/admin/users',
    },
    {
      name: 'Sessions',
      link: '/admin/sessions',
    },
    {
      name: 'Inbox',
      link: '/admin/inbox',
    },
    {
      name: 'Actions',
      link: '/admin/actions',
    },
  ];

  const location = useLocation();
  const isMenuItemActive = (menuItemLink: string) => {
    if (menuItemLink === '/admin') {
      return location.pathname === menuItemLink;
    }
    return location.pathname.startsWith(menuItemLink);
  };

  return (
    <nav
      className="flex-no-wrap relative flex w-full items-center justify-between bg-neutral-100 py-2 shadow-md shadow-black/5 dark:bg-neutral-600 dark:shadow-black/10 lg:flex-wrap lg:justify-start lg:py-4"
      data-te-navbar-ref
    >
      <div className="flex w-full flex-wrap items-center justify-between px-3">
        <button
          className="block border-0 bg-transparent px-2 text-neutral-500 hover:no-underline hover:shadow-none focus:no-underline focus:shadow-none focus:outline-none focus:ring-0 dark:text-neutral-200 lg:hidden"
          type="button"
          data-te-collapse-init
          data-te-target="#navbarSupportedContent1"
          aria-controls="navbarSupportedContent1"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span className="[&>svg]:w-7">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              className="h-7 w-7"
            >
              <path
                fillRule="evenodd"
                d="M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z"
                clipRule="evenodd"
              />
            </svg>
          </span>
        </button>

        <div
          className="!visible hidden flex-grow basis-[100%] items-center lg:!flex lg:basis-auto"
          id="navbarSupportedContent1"
          data-te-collapse-item
        >
          <a
            className="mb-4 mt-4 mr-5 flex items-center lg:mb-0 lg:mt-0"
            href="#"
          >
            <img className="h-6 mr-2" src={logo} loading="lazy" />
            <h5 className=" text-blue-900 text-xl">Singularity Bridge</h5>
          </a>

          <ul
            className="list-style-none mr-auto flex flex-col pl-0 lg:flex-row"
            data-te-navbar-nav-ref
          >
            {menuItems.map((item) => {
              const isActive = isMenuItemActive(item.link);

              const menuStyle = isActive
                ? 'text-sm text-blue-300 hover:text-neutral-700 focus:text-neutral-700 disabled:text-black/30 dark:text-neutral-200 dark:hover:text-neutral-300 dark:focus:text-neutral-300 lg:px-2'
                : 'text-sm text-neutral-500 hover:text-neutral-700 focus:text-neutral-700 disabled:text-black/30 dark:text-neutral-200 dark:hover:text-neutral-300 dark:focus:text-neutral-300 lg:px-2';

              return (
                <li
                  className="mb-4 lg:mb-0 lg:pr-2"
                  data-te-nav-item-ref
                  key={item.name}
                >
                  <a
                    className={menuStyle}
                    href={item.link}
                    data-te-nav-link-ref
                  >
                    {item.name}
                  </a>
                </li>
              );
            })}
          </ul>
        </div>

        <SessionView />
      </div>
    </nav>
  );
});


components/admin/SelectInput.tsx:
import React, { useEffect, useRef } from 'react';
import { Select, initTE } from 'tw-elements';

interface ProcessorOption {
  value: string;
  text: string;
  secondaryText: string;
}

interface SelectInputProps {
  options: ProcessorOption[];
  value: string;
  onChange: (value: string) => void;
}

const SelectInput: React.FC<SelectInputProps> = ({
  options,
  value,
  onChange,
}) => {
  const selectRef = useRef<HTMLSelectElement>(null);

  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    onChange(event.target.value);
  };

  useEffect(() => {
    initTE({ Select });

    const selectInstance = Select.getInstance(selectRef.current);
    if (selectInstance) {
      selectInstance.setValue(value);
    }
  }, [value]);

  return (
    <div className="mb-4">
      <select
        data-te-select-init
        data-te-select-filter="true"
        data-te-select-size="lg"
        onChange={handleChange}
        ref={selectRef}
      >
        {options.map((option) => (
          <option
            key={option.value}
            value={option.value}
            data-te-select-secondary-text={option.secondaryText}
          >
            {option.text}
          </option>
        ))}
      </select>
    </div>
  );
};

export { SelectInput };


components/admin/SessionView.tsx:
import React from 'react';
import { observer } from 'mobx-react';
import { useRootStore } from '../../store/common/RootStoreContext';
import {
  BuildingOffice2Icon,
  ChatBubbleLeftEllipsisIcon,
  UserIcon,
} from '@heroicons/react/24/outline';
import Button from '../core/Button';
import {
  getSessionById,
  createSession,
  getUserId,
  getCompanyId,
} from '../../services/api/sessionService';

export const SessionView = observer(() => {

  const rootStore = useRootStore();

  const loadSession = async () => {
    
    const userId = getUserId();
    const companyId = getCompanyId();

    if (!userId || !companyId) {
      console.log('no user or company id, cannot load session');
      return;
    }

    const session = await createSession(userId, companyId);
    const sessionData = await getSessionById(session._id);
    rootStore.sessionStore.setActiveSession(sessionData);
  };

  if (!rootStore.sessionStore.activeSession) {
    return (
      <div className="p-3">
        Session not loaded{' '}
        <Button onClick={loadSession} additionalClassName=" text-sm p-1">
          load session
        </Button>{' '}
      </div>
    );
  }

  return (
    <div className="relative flex px-4 space-x-3 mr-4 bg-cyan-500 py-3 rounded-3xl bg-opacity-30">
      <div className="flex items-center space-x-1.5">
        <BuildingOffice2Icon className="w-4 h-4 text-cyan-700" />
        <div className="   text-cyan-950  text-sm">
          {rootStore.sessionStore.activeSession.companyName}
        </div>
      </div>
      <div className="flex items-center space-x-1.5">
        <ChatBubbleLeftEllipsisIcon className="w-4 h-4 text-cyan-700" />
        <div className=" text-sm  text-cyan-950">
          {rootStore.sessionStore.activeSession.assistantName}
        </div>
      </div>
      <div className="flex items-center space-x-1.5">
        <UserIcon className="w-4 h-4  cyan-violet-700" />
        <div className=" text-cyan-950 text-sm">
          {rootStore.sessionStore.activeSession.userName}
        </div>
      </div>
    </div>
  );
});


components/admin/TextareaWithLabel.tsx:
import React, { useEffect } from 'react';
import { Input, initTE } from 'tw-elements';

interface TextareaWithLabelProps {
  id: string;
  label: string;
  rows?: number;
  placeholder?: string;
  value: string;
  onChange: (value: string) => void;
}

const TextareaWithLabel: React.FC<TextareaWithLabelProps> = ({
  id,
  label,
  rows = 10,
  placeholder = '',
  value,
  onChange,
}) => {
  useEffect(() => {
    initTE({ Input });
  }, []);

  return (
    <div className="relative mb-3" data-te-input-wrapper-init>
      <textarea
        className="peer m-0 block h-auto w-full rounded border border-solid border-neutral-300 bg-transparent bg-clip-padding px-3 py-4 text-base font-normal leading-tight text-neutral-700 transition duration-200 ease-linear placeholder:text-transparent focus:border-primary focus:pb-[0.625rem] focus:pt-[1.625rem] focus:text-neutral-700 focus:outline-none peer-focus:text-primary dark:border-neutral-600 dark:text-neutral-200 dark:focus:border-primary dark:peer-focus:text-primary [&:not(:placeholder-shown)]:pb-[0.625rem] [&:not(:placeholder-shown)]:pt-[1.625rem]"
        id={id}
        rows={rows}
        placeholder={placeholder}
        value={value}
        onChange={(e) => onChange(e.target.value)}
      ></textarea>
      <label
        htmlFor={id}
        className="pointer-events-none absolute left-0 top-0 origin-[0_0] border border-solid border-transparent px-3 py-4 text-neutral-500 transition-[opacity,_transform] duration-200 ease-linear peer-focus:-translate-y-2 peer-focus:translate-x-[0.15rem] peer-focus:scale-[0.85] peer-focus:text-primary peer-[:not(:placeholder-shown)]:-translate-y-2 peer-[:not(:placeholder-shown)]:translate-x-[0.15rem] peer-[:not(:placeholder-shown)]:scale-[0.85] motion-reduce:transition-none dark:text-neutral-200 dark:peer-focus:text-primary"
      >
        {label}
      </label>
    </div>
  );
};

export { TextareaWithLabel };


components/admin/chatSessions/ChatSessionCard.tsx:
import { Link } from 'react-router-dom';
import { IChatSession } from '../../../store/models/ChatSession';

const ChatSessionCard: React.FC<{ session: IChatSession }> = ({ session }) => {
  return (
    <div className="flex flex-col rounded-lg bg-white shadow-[0_2px_15px_-3px_rgba(0,0,0,0.07),0_10px_20px_-2px_rgba(0,0,0,0.04)] dark:bg-neutral-700 md:max-w-xl md:flex-row mb-4">
      <img
        className="h-96 w-full rounded-t-lg object-cover md:h-auto md:w-48 md:rounded-none md:rounded-l-lg"
        src="https://tecdn.b-cdn.net/wp-content/uploads/2020/06/vertical.jpg"
        alt=""
      />
      <div className="flex flex-col justify-start p-6">
        <h5 className="mb-2 text-xl font-medium text-neutral-800 dark:text-neutral-50 text-wrap">
          Chat Session: {session._id}
        </h5>
        <p className="mb-4 text-base text-neutral-600 dark:text-neutral-200">
          User ID: {session.user_id}
        </p>
        <p className="mb-4 text-base text-neutral-600 dark:text-neutral-200">
          Chatbot Key: {session.chatbot_key.key}
        </p>
        <p className="text-xs text-neutral-500 dark:text-neutral-300">
          Created At: {session.created_at.toString()}
        </p>
        <Link
          to={`/admin/chat-sessions/${session._id}`}
          className="text-blue-600 mt-2"
        >
          View Session
        </Link>
      </div>
    </div>
  );
};

export { ChatSessionCard };


components/admin/chatbots/ChatbotCard.tsx:
import { Link } from 'react-router-dom';
// import { Chatbot } from "../../../services/ChatbotService";
import {
  ChartPieIcon,
  DocumentTextIcon,
  PencilSquareIcon,
} from '@heroicons/react/24/outline';
import { IChatbot } from '../../../store/models/Chatbot';

const ChatbotCard: React.FC<{ chatbot: IChatbot }> = ({ chatbot }) => {
  const defaultImage = 'admin/chatbot.png';

  return (
    <Link to={`/admin/chatbots/${chatbot.key}`}>
      <div className="flex flex-col rounded-lg bg-white shadow-[0_2px_15px_-3px_rgba(0,0,0,0.07),0_10px_20px_-2px_rgba(0,0,0,0.04)] dark:bg-neutral-700 md:max-w-xl md:flex-row mb-4">
        <img
          className="h-96 w-full rounded-t-lg object-cover md:h-auto md:w-48 md:rounded-none md:rounded-l-lg"
          src={chatbot.avatarImage || defaultImage}
          alt=""
        />
        <div className="flex flex-col justify-start py-3 px-4">
          <h5 className="mb-2 text-xl font-medium text-neutral-800 dark:text-neutral-50 text-wrap">
            {chatbot.name}
          </h5>
          <p className="mb-4 text-base text-neutral-600 dark:text-neutral-200">
            {chatbot.description}
          </p>
          <div className="flex mt-auto">
            <button className="mr-4">
              <PencilSquareIcon className="h-5 w-5 text-slate-400" />
            </button>
            <button className="mr-4">
              <DocumentTextIcon className="h-5 w-5 text-slate-400" />
            </button>
            <button>
              <ChartPieIcon className="h-5 w-5 text-slate-400" />
            </button>
          </div>
        </div>
      </div>
    </Link>
  );
};

export { ChatbotCard };


components/chat/AudioCircle.tsx:
import React, { useEffect, useRef, useState } from 'react';

interface AudioCircleProps {
  active: boolean;
  scaleFrom: number;
  scaleTo: number;
  children?: React.ReactNode;
}

const AudioCircle: React.FC<AudioCircleProps> = ({
  active,
  scaleFrom,
  scaleTo,
  children,
}) => {
  const [scale, setScale] = useState(scaleFrom);

  const getRandomRadius = () => {
    const minRadius = scaleFrom;
    const maxRadius = scaleTo;
    return Math.floor(Math.random() * (maxRadius - minRadius + 1) + minRadius);
  };

  useEffect(() => {
    if (!active) return;

    const interval = setInterval(() => {
      setScale(getRandomRadius());
    }, 60);

    return () => clearInterval(interval);
  }, [active, getRandomRadius, scaleFrom, scaleTo]);

  return (
    <>
      <div style={{ width: scaleTo, height: scaleTo, position: 'relative' }}>
        <div
          className=""
          style={{
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            overflow: 'hidden',
            width: `${scale}px`,
            height: `${scale}px`,
            transition: 'width 0.3s ease, height 0.3s ease',
          }}
        >
          {children}
        </div>
      </div>
    </>
  );
};

export { AudioCircle };


components/chat/ChatFooterContainer.tsx:
interface ChatFooterContainerProps {
  children: React.ReactNode;
}

const ChatFooterContainer: React.FC<ChatFooterContainerProps> = ({
  children,
}) => {
  return <footer className="text-center font-light">{children}</footer>;
};

export { ChatFooterContainer };


components/chat/ChatFooterText.tsx:
import { ChevronRightIcon, MicrophoneIcon } from '@heroicons/react/24/outline';
import React, { useEffect } from 'react';
import useSpeechToText from 'react-hook-speech-to-text';
import { ChatFooterProps, getVoiceMap } from './common';

const ChatFooterText: React.FC<ChatFooterProps> = ({
  onSendMessage,
  autoTranslateTarget,
}) => {
  const {
    error,
    interimResult,
    isRecording,
    results,
    startSpeechToText,
    stopSpeechToText,
  } = useSpeechToText({
    crossBrowser: true,
    continuous: true,
    useLegacyResults: false,
    useOnlyGoogleCloud: false,
    speechRecognitionProperties: {
      lang: getVoiceMap(autoTranslateTarget).speeachRecognitionProperties.lang,
      interimResults: true,
    },
    googleApiKey: 'AIzaSyCmCIWBPBwiYiwHa0KoiL892ucEhRy8hZ8',
    googleCloudRecognitionConfig: {
      languageCode:
        getVoiceMap(autoTranslateTarget).googleCloudRecognitionConfig?.lang,
    },
  });

  useEffect(() => {
    if (interimResult) {
      setUserInput(interimResult);
      return;
    }

    if (results.length > 0) {
      const lastResult = results
        .map((result) =>
          typeof result === 'string' ? result : result.transcript,
        )
        .join(' ');

      setUserInput(lastResult);
    }
  }, [results, interimResult]);

  const [userInput, setUserInput] = React.useState('');
  const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
    if (event.key === 'Enter') {
      event.preventDefault();
      handleSendMessage();
    }
  };

  const handleSendMessage = () => {
    onSendMessage(userInput);
    setUserInput('');
    results.length = 0;
    stopSpeechToText();
  };

  if (error) return <p>Web Speech API is not available in this browser </p>;

  return (
    <div className="flex flex-row items-center bg-white p-3 w-full">
      <div className="flex-grow mr-4">
        <div className="relative w-full">
          <input
            value={userInput}
            onChange={(e) => {
              setUserInput(e.target.value);
            }}
            onKeyDown={handleKeyDown}
            type="text"
            className="flex w-full border rounded-md h-12 focus:outline-none focus:border-indigo-300 p-2"
          />
        </div>
      </div>
      <div>
        <button
          className="flex items-center justify-center"
          onClick={handleSendMessage}
        >
          <span>
            <ChevronRightIcon className="h-8 w-8 text-blue-800 " />
          </span>
        </button>
      </div>
    </div>
  );
};

export { ChatFooterText };


components/chat/ChatFooterVoice.tsx:
import {
  MicrophoneIcon,
  PaperAirplaneIcon,
  XMarkIcon,
  UserIcon,
  ChatBubbleLeftEllipsisIcon,
  CloudArrowDownIcon,
  MinusIcon,
} from '@heroicons/react/24/outline';
import React, { useEffect, useRef, useState } from 'react';
import useSpeechToText from 'react-hook-speech-to-text';
import { ChatFooterProps, ChatState, getVoiceMap } from './common';
import { motion } from 'framer-motion';
import { useTimer } from '../../services/useTimer';
import { AudioCircle } from './AudioCircle';
import SpeechRecognition, {
  useSpeechRecognition,
} from 'react-speech-recognition';

const ChatFooterVoice: React.FC<ChatFooterProps> = ({
  onSendMessage,
  autoTranslateTarget,
  chatState,
}) => {
  const {
    transcript,
    interimTranscript,
    // finalTranscript,
    resetTranscript,
    listening,
    browserSupportsSpeechRecognition,
    isMicrophoneAvailable,
  } = useSpeechRecognition();

  const [userInput, setUserInput] = React.useState('');
  const { timerRunning, startTimer, resetTimer } = useTimer(() => {
    console.log('send message timer');
    SpeechRecognition.stopListening();
    handleSendMessage();
  });

  const [isEnabled, setIsEnabled] = useState(false);
  const primaryActionButtonStyle = 'text-gray-100';

  const getActionIcon = () => {
    switch (chatState) {
      case ChatState.LISTENING:
        return <MicrophoneIcon className={primaryActionButtonStyle} />;
      case ChatState.PLAYING:
        return (
          <ChatBubbleLeftEllipsisIcon className={primaryActionButtonStyle} />
        );
      case ChatState.GETTING_DATA:
        return (
          <ChatBubbleLeftEllipsisIcon className={primaryActionButtonStyle} />
        );
      default:
        return (
          <ChatBubbleLeftEllipsisIcon className={primaryActionButtonStyle} />
        );
    }
  };

  const voiceLanguage =
    getVoiceMap(autoTranslateTarget).googleCloudRecognitionConfig?.lang;

  useEffect(() => {
    if (chatState === ChatState.LISTENING) {
      setIsEnabled(true);
    } else {
      setIsEnabled(false);
    }
  }, [chatState]);

  useEffect(() => {
    if (transcript) {
      setUserInput(transcript);
      resetTimer();
      startTimer();
    }
  }, [transcript]);

  useEffect(() => {
    if (isEnabled && !listening) {
      SpeechRecognition.startListening({
        continuous: true,
        language: voiceLanguage,
      });
    }
  }, [isEnabled]);

  const handleSendMessage = () => {
    if (transcript === '') return;
    onSendMessage(transcript);
    setUserInput('');
    resetTranscript();
  };

  const handleStartSpeechToText = () => {
    if (!isEnabled) return;

    resetTranscript();
    SpeechRecognition.startListening({
      continuous: true,
      language: voiceLanguage,
    });
  };

  const handleClearInput = () => {
    setUserInput('');
    resetTimer();
    resetTranscript();
  };

  // if (error) return <p>Web Speech API is not available in this browser </p>;
  if (!browserSupportsSpeechRecognition) {
    return <span>Browser doesn't support speech recognition.</span>;
  }

  const actionButtonStyle = 'h-5 w-5 text-gray-500';

  const breathingAnimation = {
    scale: [1, 1.01, 1],
    transition: {
      duration: 1.7,
      repeat: Infinity,
    },
  };

  const getPrimaryActionButtonStyle = () => {
    switch (chatState) {
      case ChatState.LISTENING:
        if (listening) {
          return 'bg-rose-500 rounded-full p-4';
        } else {
          return 'bg-rose-300 rounded-full p-4';
        }
      case ChatState.PLAYING:
        return 'bg-sky-500 rounded-full p-4';
      case ChatState.GETTING_DATA:
        return 'bg-sky-300 rounded-full p-4';
    }
  };

  const handlePrimaryActionButtonClick = () => {
    resetTimer();

    if (chatState === ChatState.LISTENING) {
      if (listening) {
        SpeechRecognition.stopListening();
      } else {
        handleStartSpeechToText();
      }
    }
  };

  return (
    <>
      <div className="flex flex-col">
        <div className="relative w-full p-4 text-lg text-slate-500 h-20 flex items-center justify-center">
          {userInput || ''}
        </div>

        <div className="flex flex-row justify-center pt-4 pb-4 space-x-8 bg-slate-100">
          <button
            className="flex items-center justify-center"
            onClick={handleClearInput}
          >
            <span>
              {chatState === ChatState.LISTENING && (
                <XMarkIcon className={actionButtonStyle} />
              )}
            </span>
          </button>

          <motion.div
            animate={
              listening || chatState === ChatState.PLAYING
                ? breathingAnimation
                : {}
            }
          >
            <button
              className={getPrimaryActionButtonStyle()}
              onClick={handlePrimaryActionButtonClick}
            >
              <span className="">
                <AudioCircle
                  active={chatState === ChatState.PLAYING}
                  scaleFrom={42}
                  scaleTo={47}
                >
                  {getActionIcon()}
                </AudioCircle>
              </span>
              {/* <span>{getActionIcon()}</span> */}
            </button>
          </motion.div>

          <button
            className="flex items-center justify-center"
            onClick={() => {
              resetTimer();
              SpeechRecognition.stopListening();
              handleSendMessage();
            }}
          >
            <span>
              {chatState === ChatState.LISTENING && (
                <PaperAirplaneIcon className={actionButtonStyle} />
              )}
            </span>
          </button>
        </div>
      </div>

      <div className="relative w-full"></div>
    </>
  );
};

export { ChatFooterVoice };


components/chat/LabelText.tsx:
import React from 'react';

interface LabelTextProps {
  label: JSX.Element;
  text: string | number | JSX.Element;
  labelVerticalAlign?: 'top' | 'center';
  layout?: 'horizontal' | 'vertical';
}

const LabelText: React.FC<LabelTextProps> = ({
  label,
  text,
  labelVerticalAlign = 'center',
  layout = 'horizontal',
}) => {
  const containerClass = layout === 'vertical' ? 'flex-col' : 'flex';
  const itemAlignClass =
    layout === 'vertical' || labelVerticalAlign === 'top'
      ? 'items-start'
      : 'items-center';
  return (
    <div className={`flex ${containerClass} ${itemAlignClass}`}>
      <div className="">{label}</div>
      <div>{text}</div>
    </div>
  );
};

export { LabelText };


components/chat/common.tsx:
export enum ChatState {
  PLAYING = 'PLAYING',
  LISTENING = 'LISTENING',
  GETTING_DATA = 'GETTING_DATA',
}

export interface ChatFooterProps {
  onSendMessage: (value: string) => void;
  autoTranslateTarget: string;
  chatState: ChatState;
}

export interface LanguageVoiceMap {
  speeachRecognitionProperties: {
    lang: string;
  };
  googleCloudRecognitionConfig: {
    lang: string;
  };
}

export const languageVoiceMap: { [key: string]: LanguageVoiceMap } = {
  it: {
    speeachRecognitionProperties: {
      lang: 'it-IT',
    },
    googleCloudRecognitionConfig: {
      lang: 'it-IT',
    },
  },
  he: {
    speeachRecognitionProperties: {
      lang: 'he-IL',
    },
    googleCloudRecognitionConfig: {
      lang: 'iw-IL',
    },
  },
  en: {
    speeachRecognitionProperties: {
      lang: 'en-US',
    },
    googleCloudRecognitionConfig: {
      lang: 'en-US',
    },
  },
  ru: {
    speeachRecognitionProperties: {
      lang: 'ru-RU',
    },
    googleCloudRecognitionConfig: {
      lang: 'ru-RU',
    },
  },
  ar: {
    speeachRecognitionProperties: {
      lang: 'ar-DZ',
    },
    googleCloudRecognitionConfig: {
      lang: 'ar-DZ',
    },
  },
};

export const getVoiceMap = (language: string): LanguageVoiceMap => {
  return languageVoiceMap[language];
};


components/chat-container/AssistantMessage.tsx:
import React from 'react';
import { SparklesIcon } from '@heroicons/react/24/solid';
import ReactMarkdown from 'react-markdown';

interface AssistantMessageProps {
  text: string;
  assistantName?: string;
}

const AssistantMessage: React.FC<AssistantMessageProps> = ({
  text,
  assistantName,
}) => {
  return (
    <div className="flex gap-3 my-4 text-gray-600 text-sm flex-1">
      <span className="relative flex shrink-0 overflow-hidden rounded-full w-8 h-8">
        <div className="rounded-full bg-gray-100 border p-1">
          <SparklesIcon className="w-5 h-5 text-gray-700" />
        </div>
      </span>
      <div className="leading-relaxed">
        <span className="block font-bold text-gray-800">{assistantName}</span>
        <ReactMarkdown className="prose prose-sm ">{text}</ReactMarkdown>
      </div>
    </div>
  );
};

export { AssistantMessage };


components/chat-container/ChatContainer.tsx:
import React, { useEffect, useRef, useState } from 'react';
import { Header } from './Header';
import { AssistantMessage } from './AssistantMessage';
import { UserMessage } from './UserMessage';
import {
  PaperAirplaneIcon,
  PlusIcon,
  TrashIcon,
} from '@heroicons/react/24/outline';
import {
  endSession,
  getSessionMessages,
  handleUserInput,
} from '../../services/api/assistantService';
import {
  EVENT_CHAT_SESSION_DELETED,
  EVENT_SET_ACTIVE_ASSISTANT,
} from '../../utils/eventNames';
import { emitter, useEventEmitter } from '../../services/mittEmitter';
import { observer } from 'mobx-react';
import { useRootStore } from '../../store/common/RootStoreContext';
import { IAssistant } from '../../store/models/Assistant';
import {
  getSessionById,
  updateSessionAssistant,
} from '../../services/api/sessionService';
import { HumanAgentResponseMessage } from './HumanAgentResponseMessage';

interface Metadata {
  message_type: string;
}

interface ChatMessage {
  content: string;
  role: string;
  metadata?: Metadata;
  assistantName?: string;
}

const ChatContainer = observer(() => {
  const rootStore = useRootStore();
  const messagesEndRef = useRef<null | HTMLDivElement>(null);
  const [message, setMessage] = useState('');
  const [isMinimized, setIsMinimized] = useState(false);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [assistant, setAssistant] = useState<IAssistant>();

  const userId = rootStore.sessionStore.activeSession?.userId;
  const assistantId = rootStore.sessionStore.activeSession?.assistantId;
  const companyId = rootStore.sessionStore.activeSession?.companyId;

  useEffect(() => {
    if (assistantId && rootStore.assistantsLoaded) {
      setAssistant(rootStore.getAssistantById(assistantId));
    }
  }, [assistantId, rootStore.sessionStore.activeSession]);

  const loadMessages = async () => {
    if (assistant && userId) {
      const sessionMessages = await getSessionMessages(companyId || '', userId);
      const chatMessages = sessionMessages.map(mapToChatMessage);
      setMessages(chatMessages.reverse());
    }
  };

  useEffect(() => {
    loadMessages();
  }, [userId, assistant?._id]);

  const handleAssistantUpdated = async (assistantId: string) => {
    console.log('set assistantId', assistantId);
    await updateSessionAssistant(
      rootStore.sessionStore.activeSession?._id || '',
      assistantId
    );
    const session = await getSessionById(
      rootStore.sessionStore.activeSession?._id || ''
    );
    rootStore.sessionStore.setActiveSession(session);
    setAssistant(rootStore.getAssistantById(assistantId));
  };

  useEventEmitter<string>(EVENT_SET_ACTIVE_ASSISTANT, handleAssistantUpdated);

  const mapToChatMessage = (message: any): ChatMessage => {
    return {
      content: message.content[0].text.value,
      role: message.role,
      metadata: message.metadata,
      assistantName: message.assistantName,
    };
  };

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const handleSubmitMessage = (message: string) => {
    setMessage('');
    setMessages((prevMessages) => [
      ...prevMessages,
      { content: message, role: 'user' },
    ]);

    if (assistant && userId && companyId) {
      handleUserInput({
        userInput: message,
        companyId: companyId,
        userId: userId,
      }).then((response) => {
        setMessages((prevMessages) => [
          ...prevMessages,
          { content: response, role: 'assistant' },
        ]);
      });
    }
  };
  const handleReload = async () => {
    if (assistant && userId && companyId) {
      await endSession(companyId, userId);
      rootStore.sessionStore.clearActiveSession();
      emitter.emit(EVENT_CHAT_SESSION_DELETED, 'Chat session deleted');
    }
  };

  const handleMinimize = () => {
    setIsMinimized(!isMinimized);
  };

  if (isMinimized) {
    return (
      <button
        className="fixed mr-3 mb-3 bottom-4 right-4 w-12 h-12 bg-slate-500 rounded-full flex items-center justify-center"
        onClick={handleMinimize}
      >
        <PlusIcon className="h-6 w-6 text-white" />
      </button>
    );
  }

  return (
    <>
      <div
        style={{
          boxShadow: '0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgb(0 0 0 / 0.05)',
          zIndex: 5000,
        }}
        className="fixed bottom-[calc(2rem)] right-0 mr-7 bg-white p-5 rounded-lg border border-[#e5e7eb] w-[340px] h-[575px] flex flex-col"
      >
        <Header
          title={assistant?.name || ''}
          description={assistant?.description || ''}
          onMinimize={handleMinimize}
        />
        <div
          className="flex-grow overflow-auto pr-4 scrollbar-thin scrollbar-thumb-neutral-300"
          style={{
            minWidth: '100%',
          }}
        >
          {messages.map((message, index) => {
            if (message.metadata?.message_type === 'human-agent-response') {
              return (
                <HumanAgentResponseMessage key={index} text={message.content} />
              );
            } else if (message.role === 'assistant') {
              return <AssistantMessage key={index} text={message.content} assistantName={message.assistantName} />;
            } else {
              return <UserMessage key={index} text={message.content} />;
            }
          })}

          <div ref={messagesEndRef} />
        </div>
        <div className="flex items-center pt-0 mt-1">
          <div className="flex items-center justify-center w-full space-x-2">
            <input
              className="flex h-10 w-full rounded-md border border-[#e5e7eb] px-3 py-2 text-sm placeholder-[#6b7280] focus:outline-none focus:ring-2 focus:ring-[#9ca3af] disabled:cursor-not-allowed disabled:opacity-50 text-[#030712] focus-visible:ring-offset-2"
              placeholder="Type your message"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  handleSubmitMessage(message);
                  e.preventDefault(); // Prevents the addition of a new line in the input after pressing 'Enter'
                }
              }}
            />
            <button
              onClick={() => handleSubmitMessage(message)}
              className="inline-flex items-center justify-center rounded-lg  disabled:pointer-events-none disabled:opacity-50 bg-gray-800 hover:bg-[#111827E6] h-10 px-2 py-2"
            >
              <PaperAirplaneIcon className="h-5 w-5 text-zinc-50 " />
            </button>
            <button
              onClick={handleReload}
              className="inline-flex items-center justify-center rounded-lg  disabled:pointer-events-none disabled:opacity-50 bg-gray-800 hover:bg-[#111827E6] h-10 px-2 py-2"
            >
              <TrashIcon className="h-5 w-5 text-warning-200" />
            </button>
          </div>
        </div>
      </div>
    </>
  );
});

export { ChatContainer };


components/chat-container/Header.tsx:
import React, { useState } from 'react';
import { ChevronDownIcon } from '@heroicons/react/24/outline';
import logo from '../../assets/l3.png';

interface HeaderProps {
  title: string;
  description: string;
  onMinimize: () => void;
}

const Header: React.FC<HeaderProps> = ({ title, description, onMinimize }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const toggleDescription = () => {
    setIsExpanded(!isExpanded);
  };

  const renderDescription = () => {
    if (description.length > 100 && !isExpanded) { // Assuming 100 characters as roughly 2 lines
      return (
        <p className="text-sm text-[#6b7280] leading-4 cursor-pointer" onClick={toggleDescription}>
          {`${description.substring(0, 97)}...`}
        </p>
      );
    }
    return (
      <p className="text-sm text-[#6b7280] leading-4 cursor-pointer" onClick={toggleDescription}>
        {description}
      </p>
    );
  };

  return (
    <>
      <div className="flex justify-between items-center space-y-2 space-x-3 pb-2">
        <img
          className="h-10 bg-lime-200 rounded-full mt-2 p-2"
          src={logo}
          loading="lazy"
        />
        <div className="flex-1">
          <h2 className="font-semibold text-lg tracking-tight">{title}</h2>
        </div>
        <div className="flex space-x-2">
          <button
            className="bg-gray-200 rounded-full p-2 hover:bg-gray-300"
            onClick={onMinimize}
          >
            <ChevronDownIcon className="h-3 w-3 text-gray-700" />
          </button>
        </div>
      </div>
      <div className="flex items-start pb-5">
        {renderDescription()}
      </div>
    </>
  );
};

export { Header };


components/chat-container/HumanAgentResponseMessage.tsx:
import { UserIcon } from '@heroicons/react/24/outline';
import { SparklesIcon } from '@heroicons/react/24/solid';
import React from 'react';
import ReactMarkdown from 'react-markdown';

interface HumanAgentResponseMessageProps {
  text: string;
}

const HumanAgentResponseMessage: React.FC<HumanAgentResponseMessageProps> = ({ text }) => {
  return (
    <div className="flex bg-yellow-100 gap-3 my-4 text-gray-600 text-sm flex-1 py-3">
    <span className="relative flex shrink-0 overflow-hidden rounded-full w-8 h-8">
      <div className="rounded-full bg-yellow-300 border p-1">
        <UserIcon className="w-5 h-5 text-gray-700" />
      </div>
    </span>
    <div className="leading-relaxed">
      <span className="block font-bold text-gray-800">Support Reviewer </span>
      <ReactMarkdown className="prose prose-sm ">{text}</ReactMarkdown>
    </div>
  </div>
  );
};

export { HumanAgentResponseMessage };


components/chat-container/UserMessage.tsx:
import React from 'react';
import { UserIcon } from '@heroicons/react/24/outline';

interface UserMessageProps {
  text: string;
}

const UserMessage: React.FC<UserMessageProps> = ({ text }) => {
  return (
    <div className="flex gap-3 my-4 text-gray-600 text-sm flex-1">
      <span className="relative flex shrink-0 overflow-hidden rounded-full w-8 h-8">
        <div className="rounded-full bg-gray-100 border p-1">
          <UserIcon className="w-5 h-5 text-gray-800" />
        </div>
      </span>
      <p className="leading-relaxed">
        <span className="block font-bold text-gray-800">Human</span>
        {text}
      </p>
    </div>
  );
};

export { UserMessage };


components/core/Button.tsx:
import React from 'react';
import clsx from 'clsx';

export interface ButtonProps {
  type?: 'button' | 'submit' | 'reset';
  onClick?: () => void;
  additionalClassName?: string;
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({
  type = 'button',
  onClick,
  additionalClassName,
  children,
}) => {
  const className = clsx(
    'bg-primary',
    'text-white',
    'px-2.5',
    'py-1.5',
    'mr-2 mb-2',
    'rounded-md',
    'text-base',
    additionalClassName,
  );

  return (
    <button type={type} onClick={onClick} className={className}>
      {children}
    </button>
  );
};

export default Button;


components/core/LoadingButton.tsx:
import React from 'react';
import clsx from 'clsx';
import { ButtonProps } from './Button';

interface LoadingButtonProps extends ButtonProps {
    isLoading: boolean;
}

const LoadingButton: React.FC<LoadingButtonProps> = ({
    isLoading,
    children,
    additionalClassName,
    ...props
}) => {
    const className = clsx(
        'bg-primary',
        'text-white',
        'px-2.5',
        'py-1.5',
        'mr-2 mb-2',
        'rounded-md',
        'text-base',
        additionalClassName,
    );

    return (
        <button {...props} disabled={isLoading} className={className}>
            {isLoading ? 'Loading...' : children}
        </button>
    );
};

export default LoadingButton;

components/core/ModalDialog.tsx:
import React from 'react';
import {
  TEModal,
  TEModalDialog,
  TEModalContent,
  TEModalHeader,
  TEModalBody,
} from 'tw-elements-react';

interface ModalDialogProps {
  title: string;
  onClose: () => void;
  onSave: () => void;
  isOpen: boolean;
  children: React.ReactNode;
}

const ModalDialog: React.FC<ModalDialogProps> = ({
  title,
  children,
  onClose,
  isOpen,
}) => {
  return (
    <TEModal show={isOpen} setShow={onClose}>
      <TEModalDialog>
        <TEModalContent>
          <TEModalHeader>
            <h5 className="text-xl font-medium leading-normal text-neutral-800 dark:text-neutral-200">
              {title}
            </h5>

            <button
              type="button"
              className="box-content rounded-none border-none hover:no-underline hover:opacity-75 focus:opacity-100 focus:shadow-none focus:outline-none"
              onClick={onClose}
              aria-label="Close"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                strokeWidth="1.5"
                stroke="currentColor"
                className="h-6 w-6"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </TEModalHeader>
          <TEModalBody>{children}</TEModalBody>
        </TEModalContent>
      </TEModalDialog>
    </TEModal>
  );
};

export { ModalDialog };


custom-hooks/useChatbot.ts:
// custom-hooks/useChatbot.tsx

import { useEffect, useState } from 'react';
import { Chatbot } from '../services/ChatbotService';

export const useChatbot = (key: string, sessionId: string) => {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<boolean>(false);

  const updateChatbot = async (updatedChatbot: Chatbot) => {
    try {
      const { _id, ...rest } = updatedChatbot;
      const response = await fetch(
        `http://127.0.0.1:5000/chatbots/${updatedChatbot.key}`,
        {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(rest),
        },
      );
      const updatedData = await response.json();
      console.log('Chatbot updated', updatedData);
      setChatbot(updatedData);
    } catch (err) {
      console.error('Error updating chatbot:', err);
    }
  };

  const setChatbotState = async (stateId: string) => {
    try {
      const response = await fetch(
        `http://127.0.0.1:5000/chat_sessions/${sessionId}/set_state`,
        {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ state: stateId }),
        },
      );

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error);
      }

      console.log('Chatbot state updated', responseData);

      if (chatbot) {
        setChatbot({
          ...chatbot,
          current_state: stateId,
        });
      }
    } catch (err) {
      console.error('Error updating chatbot state:', err);
    }
  };

  useEffect(() => {
    const fetchChatbot = async () => {
      try {
        const response = await fetch(`http://127.0.0.1:5000/chatbots/${key}`);
        const data = await response.json();
        setChatbot(data);
        setLoading(false);
      } catch (err) {
        console.error('Error fetching chatbot:', err);
        setError(true);
        setLoading(false);
      }
    };

    fetchChatbot();
  }, [key]);

  return {
    chatbot,
    setChatbot,
    loading,
    error,
    updateChatbot,
    setChatbotState,
  };
};


main.tsx:
import React from 'react';
import ReactDOM from 'react-dom/client';
import 'regenerator-runtime/runtime';
import { RecoilRoot } from 'recoil';
import './index.css';
import { browserRouter } from './Router';
import { RouterProvider } from 'react-router-dom';
// import 'tw-elements-react/dist/css/tw-elements-react.min.css';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <RecoilRoot>
    <RouterProvider router={browserRouter} />
  </RecoilRoot>,
);


pages/Admin.tsx:
import React, { useEffect } from 'react';
import { observer } from 'mobx-react-lite';
import { ContentContainer } from '../components/ContentContainer';
import { Menu } from '../components/admin/Menu';
import { ChatbotCard } from '../components/admin/chatbots/ChatbotCard';
import { ChatSessionCard } from '../components/admin/chatSessions/ChatSessionCard';
import { BreadCrumbs } from '../components/BreadCrumbs';
import { Outlet } from 'react-router-dom';
import { useRootStore } from '../store/common/RootStoreContext';

const Admin: React.FC = observer(() => {
  return (
    <>
      <Menu />
      <ContentContainer className="px-4 py-4">
        <BreadCrumbs />
        <Outlet />
      </ContentContainer>
    </>
  );
});

export { Admin };


pages/Chat.tsx:
import React, { useEffect, useRef, useState } from 'react';
import { Avatar, AvatarStyles } from '../components/Avatar';
import { useRecoilState, useRecoilValue } from 'recoil';
import {
  Message,
  messagesState,
  userProfileState,
  chatBotsState,
  SenderType,
} from '../atoms/dataStore-old';
import {
  getSessionMessages,
  getGPTCompletion,
  deleteMessageFromSession,
} from '../services/ChatService';
import { translateText } from '../services/TranslationService';
import { generateAudioFromText } from '../services/TTSService';
import { ChatMessage } from '../components/ChatMessage';
import { ContentContainer } from '../components/ContentContainer';
import { ContainerBGImage } from '../components/ContainerBGImage';
import { ChatFooterContainer } from '../components/chat/ChatFooterContainer';
import { ChatFooterText } from '../components/chat/ChatFooterText';
import { ChatFooterVoice } from '../components/chat/ChatFooterVoice';
import { ChatMessageWelcome } from '../components/ChatMessageWelcome';
import { playAudio } from '../services/AudioService';
import { ChatState } from '../components/chat/common';
import { AudioCircle } from '../components/chat/AudioCircle';
import { useParams } from 'react-router-dom';
import { useRootStore } from '../store/common/RootStoreContext';
import { observer } from 'mobx-react-lite';
import { autorun, toJS } from 'mobx';
import { LOCALSTORAGE_COMPANY_ID, getLocalStorageItem } from '../services/api/sessionService';

// move to the api service
const transformApiResponseToMessage = (message: any): Message => {
  return {
    _id: message._id,
    content: message.content.map((contentItem: any) => ({
      ...contentItem,
      options: contentItem.options
        ? contentItem.options.map((option: any) => ({
            ...option,
          }))
        : undefined,
    })),
    role: message.role,
  };
};

const transformUserMessage = (
  message: string,
  translatedMessage: string,
  userProfile: any,
): Message => {
  return {
    // _id: "", // You can leave this empty or generate a temporary unique ID if needed
    // chat_session_id: "", // You can leave this empty or assign the sessionId if needed
    content: [{ text: message, type: 'text' }],
    // created_at: new Date().toISOString(), // Set the current timestamp
    role: SenderType.user,
    // sender: userProfile.name,
    textTranslated: translatedMessage,
  };
};

const Chat = observer(() => {
  const [chatData, setChatData] = useRecoilState(messagesState);
  const [chatBots, setChatBots] = useRecoilState(chatBotsState);
  const userProfile = useRecoilValue(userProfileState);
  const chatContainerRef = useRef(null);
  // const [chatBot, setChatBot] = useState<ChatBot>(defaultChatBot);

  const [isUserInputEnabled, setIsUserInputEnabled] = useState(false);
  const [chatState, setChatState] = useState(ChatState.GETTING_DATA);
  const [audioCircleActive, setAudioCircleActive] = useState(false);

  const [sessionMessages, setSessionMessages] = useState<Message[]>([]);
  // const { sessionId = "" } = useParams<{ sessionId?: string }>();

  const rootStore = useRootStore();
  const { activeChatbot, selectedChatSession } = useRootStore();

  // useEffect(() => {
  //   rootStore.loadChatbots();
  //   rootStore.loadChatSessions("");
  // }, [rootStore]);

  // useEffect(() => {
  //   autorun(() => {
  //     if (!rootStore.chatSessionsLoaded || !rootStore.chatbotsLoaded) return;
  //     rootStore.setActiveChatSession(sessionId);
  //   });
  // }, [rootStore.chatSessionsLoaded, rootStore.chatbotsLoaded, sessionId]);

  const fetchSessionMessages = async () => {
    try {
      const chatHistoryResponse = await getSessionMessages(
        getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) || '',
      );
      console.log('loaded history: ', chatHistoryResponse);
      setSessionMessages(
        chatHistoryResponse.map(transformApiResponseToMessage),
      );
    } catch (err) {
      console.log('error loading chat history: ', err);
    }
  };

  useEffect(() => {
    autorun(() => {
      if (
        !rootStore.chatSessionsLoaded ||
        !rootStore.chatbotsLoaded ||
        !selectedChatSession
      )
        return;
      fetchSessionMessages();
    });
  }, [
    selectedChatSession,
    rootStore.selectedChatSession,
    rootStore.chatbotsLoaded,
  ]);

  // useEffect(() => {
  //   if (userProfile.activeChatBot === ChatBotNotLoaded || !chatBots) return;
  //   setChatBot(getChatBot(chatBots, userProfile.activeChatBot));
  // }, [chatBots, userProfile]);

  useEffect(() => {
    if (!activeChatbot) return;
    document.title = activeChatbot?.name;
  }, [activeChatbot]);

  useEffect(() => {
    if (chatContainerRef.current) {
      (chatContainerRef.current as HTMLElement).scrollTo({
        top: (chatContainerRef.current as HTMLElement).scrollHeight,
        behavior: 'smooth',
      });
    }
  }, [chatData]);

  const onSendMessage = async (message: string) => {
    setIsUserInputEnabled(false);
    setChatState(ChatState.GETTING_DATA);

    // const translatedMessage =
    //   chatBot && chatBot.autoTranslate
    //     ? await translateText(message, "en")
    //     : "";

    const translatedMessage = '';

    if (message !== '') {
      const userMessage = transformUserMessage(
        message,
        translatedMessage,
        userProfile,
      );
      setSessionMessages((prevChatData) => [...prevChatData, userMessage]);
    }

    const response = await getGPTCompletion(
      '',
      selectedChatSession?._id || '',
      userProfile.name,
      translatedMessage || message,
      chatData || [],
      0.7,
    );

    // const translatedResponse = chatBot.autoTranslate
    //   ? await translateText(response, chatBot.autoTranslateTarget)
    //   : "";

    setSessionMessages(response.map(transformApiResponseToMessage));
    setChatState(ChatState.PLAYING);
    setAudioCircleActive(true);
    setAudioCircleActive(false);
    setChatState(ChatState.LISTENING);
    setIsUserInputEnabled(true);
  };

  const onDeleteMessage = async (sessionId: string, messageId: string) => {
    try {
      await deleteMessageFromSession(sessionId, messageId);
      console.log('Message deleted successfully');
      fetchSessionMessages();
    } catch (error) {
      console.error('Error deleting message:', error);
    }
  };

  return (
    <>
      <ContentContainer>
        <ContainerBGImage bgImage={activeChatbot?.backgroundImage || ''}>
          <div className="flex flex-col flex-auto h-full p-0">
            <div className="flex flex-col flex-auto flex-shrink-0 h-full pt-3">
              <div
                className="flex flex-col h-full overflow-x-auto mb-4"
                ref={chatContainerRef}
              >
                <div className="flex flex-col h-full">
                  <div className="grid grid-cols-12">
                    <AudioCircle
                      active={audioCircleActive}
                      scaleFrom={10}
                      scaleTo={12}
                    />

                    <ChatMessageWelcome
                      enabled={sessionMessages.length === 0}
                      onClickStartChat={() => onSendMessage('hi')}
                    />

                    {sessionMessages.map((message: Message, index: number) => {
                      return (
                        <ChatMessage
                          key={index}
                          message={message}
                          onUserSelection={(selection) => {
                            onSendMessage(selection);
                          }}
                          onDeleteMessage={() => {
                            onDeleteMessage(
                              selectedChatSession?._id || '',
                              message._id || '',
                            );
                          }}
                        />
                      );
                    })}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </ContainerBGImage>
      </ContentContainer>
      <ChatFooterContainer>
        {/* <ChatFooterVoice
          onSendMessage={onSendMessage}
          autoTranslateTarget={chatBot?.autoTranslateTarget || "en"}
          chatState={chatState}
        /> */}
        <ChatFooterText
          onSendMessage={onSendMessage}
          autoTranslateTarget={'en'}
          // autoTranslateTarget={chatBot?.autoTranslateTarget || "en"}
          chatState={chatState}
        />
      </ChatFooterContainer>
    </>
  );
});

export { Chat };


pages/NewAssistantView.tsx:
import React, { useState, useEffect } from 'react';
import {
  DynamicForm,
  FieldConfig,
  FormValues,
  KeyValueListFieldConfig,
} from '../components/DynamicForm';
import { assistantFieldConfigs } from '../store/fieldConfigs/assistantFieldConfigs';
import { observer } from 'mobx-react';
import { useRootStore } from '../store/common/RootStoreContext';
import { IAssistant } from '../store/models/Assistant';
import { useEventEmitter } from '../services/mittEmitter';
import { EVENT_SET_ASSISTANT_VALUES } from '../utils/eventNames';

const NewAssistantView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const [isLoading, setIsLoading] = useState(false);
  const [formFields, setFormFields] = useState<FieldConfig[]>([]);

  const handleUpdateFormFields = (data: {
    name: string;
    description: string;
    prompt: string;
  }) => {
    console.log('set assistant data', data);
    setFormFields((prev) => {
      const newFormFields = prev.map((field) => {
        if (field.key === 'name') {
          field.value = data.name;
        } else if (field.key === 'description') {
          field.value = data.description;
        } else if (field.key === 'llmPrompt') {
          field.value = data.prompt;
        }
        return field;
      });
      return newFormFields;
    });
  };

  useEventEmitter<{ name: string; description: string; prompt: string }>(
    EVENT_SET_ASSISTANT_VALUES,
    handleUpdateFormFields
  );

  useEffect(() => {
    const initialFormFields = assistantFieldConfigs.map(
      ({ id, key, label, type, visibility, value }) => {
        return {
          id: id,
          key: key,
          label: label,
          value: value,
          type: type,
          visibility: visibility,
        } as KeyValueListFieldConfig;
      }
    );

    setFormFields(initialFormFields);
  }, []); // Empty dependency array ensures this runs only once

  const handleSubmit = async (values: FormValues) => {
    setIsLoading(true);
    await rootStore.createAssistant(values as unknown as IAssistant);
    setIsLoading(false);
  };
  return (
    <DynamicForm
      fields={formFields}
      onSubmit={handleSubmit}
      isLoading={isLoading}
      formType="create"
    />
  );
});

export { NewAssistantView };


pages/NewCompanyView.tsx:
import React, { useState, useEffect } from 'react';
import {
  DynamicForm,
  FieldConfig,
  FormValues,
  KeyValueListFieldConfig,
} from '../components/DynamicForm';

import { observer } from 'mobx-react';
import { useRootStore } from '../store/common/RootStoreContext';
import { companyFieldConfigs } from '../store/fieldConfigs/companyFieldConfigs';
import { ICompany } from '../store/models/Company';

const NewCompanyView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const [isLoading, setIsLoading] = useState(false);
  const [formFields, setFormFields] = useState<FieldConfig[]>([]);

  useEffect(() => {
    const initialFormFields = companyFieldConfigs.map(
      ({ id, key, label, type, visibility, value }) => {
        return {
          id: id,
          key: key,
          label: label,
          value: value,
          type: type,
          visibility: visibility,
        } as KeyValueListFieldConfig;
      }
    );

    setFormFields(initialFormFields);
  }, []); // Empty dependency array ensures this runs only once

  const handleSubmit = async (values: FormValues) => {
    setIsLoading(true);
    await rootStore.addCompany(values as unknown as ICompany);
    setIsLoading(false);
  };
  return (
    <DynamicForm
      fields={formFields}
      onSubmit={handleSubmit}
      isLoading={isLoading}
      formType="create"
    />
  );
});

export { NewCompanyView };


pages/NewUserView.tsx:
import React, { useState, useEffect } from 'react';
import {
  DynamicForm,
  FieldConfig,
  FormValues,
  KeyValueListFieldConfig,
} from '../components/DynamicForm';
import { observer } from 'mobx-react';
import { useRootStore } from '../store/common/RootStoreContext';
import { IUser } from '../store/models/User';
import { userFieldConfigs } from '../store/fieldConfigs/userFieldConfigs';


const NewUserView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const [isLoading, setIsLoading] = useState(false);
  const [formFields, setFormFields] = useState<FieldConfig[]>([]);

  useEffect(() => {
    const initialFormFields = userFieldConfigs.map(
      ({ id, key, label, type, visibility, value }) => {
        return {
          id: id,
          key: key,
          label: label,
          value: value,
          type: type,
          visibility: visibility,
        } as KeyValueListFieldConfig;
      }
    );

    setFormFields(initialFormFields);
  }, []); // Empty dependency array ensures this runs only once

  const handleSubmit = async (values: FormValues) => {
    setIsLoading(true);
    try {
      await rootStore.addUser(values as unknown as IUser);
      // Handle successful submission, e.g., show a success message, redirect, etc.
    } catch (error) {
      console.error('Failed to add user', error);
      // Handle errors, e.g., show an error message
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <DynamicForm
      fields={formFields}
      onSubmit={handleSubmit}
      isLoading={isLoading}
      formType="create"
    />
  );
});

export { NewUserView };


pages/NotFound.tsx:
import { ContainerBGImage } from '../components/ContainerBGImage';
import { ContentContainer } from '../components/ContentContainer';
import { ContentPageContainer } from '../components/ContentPageContainer';

export const NotFound = () => {
  return (
    <ContentContainer>
      <ContainerBGImage bgImage="/not-found.png">
        <ContentPageContainer>
          <h1 className=" text-3xl mb-6">Whoops! The Chatbot Escaped</h1>
          <p>
            Looks like the chatbot you were looking for has gone rogue and
            escaped from our lab. Don't worry, our team of highly trained AI
            experts are on the case and are working tirelessly to catch it and
            bring it back. In the meantime, why not try chatting with one of our
            other chatbots? They promise to behave and stay within their
            designated areas. Thank you for your understanding and patience.
          </p>
        </ContentPageContainer>
      </ContainerBGImage>
    </ContentContainer>
  );
};


pages/admin/ActionsPage.tsx:
import React from 'react';
import { observer } from 'mobx-react-lite';
import { ActionKeys, IAction } from '../../store/models/Action';
import { useRootStore } from '../../store/common/RootStoreContext';
import { IconButton } from '../../components/admin/IconButton';
import { TrashIcon } from '@heroicons/react/24/outline';
import { Table } from '../../components/Table';
import { withPage } from '../../components/admin/HOC/withPage';
import { convertToStringArray } from '../../utils/utils';
import { toJS } from 'mobx';

const ActionsView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const headers: ActionKeys[] = ['_id', 'type', 'name', 'description'];

  const handleDelete = async (actionId: string) => {
    await rootStore.deleteAction(actionId);
  };

  const ActionsColumn = (action: IAction) => (
    <div className="flex space-x-3 items-center">
      <IconButton
        icon={<TrashIcon className="w-5 h-5" />}
        onClick={() => handleDelete(action._id)}
      />
      {/* <IconButton icon={<EditIcon className="w-5 h-5" />} onClick={() => navigate(`/admin/actions/${action._id}`)} /> */}
    </div>
  );

  return (
    <div className="flex w-full justify-center">
      <div className="flex-auto">
        <Table
          headers={convertToStringArray(headers)}
          data={toJS(rootStore.actions)}
          Actions={ActionsColumn}
        />
      </div>
    </div>
  );
});

const ActionsPage = withPage(
  'Actions',
  'Manage your actions here'
)(ActionsView);
export { ActionsPage };


pages/admin/AssistantsPage.tsx:
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { Table } from '../../components/Table';
import { toJS } from 'mobx';
import { AssistantKeys, IAssistant } from '../../store/models/Assistant';
import { withPage } from '../../components/admin/HOC/withPage';
import { convertToStringArray } from '../../utils/utils';
import {
  PlayIcon,
  TrashIcon,
} from '@heroicons/react/24/outline';
import { IconButton } from '../../components/admin/IconButton';
import { emitter } from '../../services/mittEmitter';
import { EVENT_SET_ACTIVE_ASSISTANT, EVENT_SHOW_ADD_ASSISTANT_MODAL } from '../../utils/eventNames';

const AssistantsView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const navigate = useNavigate();

  const headers: AssistantKeys[] = ['name', 'description', 'voice'];

  const handleDelete = (row: IAssistant) => {
    rootStore.deleteAssistant(row._id);
  };

  const handleSetAssistant = async (row: IAssistant) => {    
    emitter.emit(EVENT_SET_ACTIVE_ASSISTANT, row._id);
  };

  const Actions = (row: IAssistant) => (
    <div className="flex space-x-2 items-center mx-1">
      <IconButton
        icon={<TrashIcon className="w-5 h-5  text-warning-900" />}
        onClick={(event) => {
          event.stopPropagation();
          handleDelete(row);
        }}
      />
      <IconButton
        icon={
          <PlayIcon className="w-5 h-5  text-warning-900" />
        }
        onClick={(event) => {
          event.stopPropagation();
          handleSetAssistant(row);
        }}
      />
    </div>
  );

  return (
    <>
      <div className="flex w-full justify-center">
        <div className=" flex-auto">
          <Table
            headers={convertToStringArray(headers)}
            data={toJS(rootStore.assistants)}
            onRowClick={(row: IAssistant) =>
              navigate(`/admin/assistants/${row._id}`)
            }
            Actions={Actions}
          />
        </div>
        <div className=" flex-0 w-96">
          
        </div>
      </div>
    </>
  );
});

const AssistantsPage = withPage(
  'AI Assistants',
  'manage your ai agents here',
  () => {
    emitter.emit(EVENT_SHOW_ADD_ASSISTANT_MODAL, 'Add Assistant');
  }
)(AssistantsView);
export { AssistantsPage };


pages/admin/ChatBotEditingViews/EditChatbot.tsx:
import React, { useState } from 'react';
import InputWithLabel from '../../../components/admin/InputWithLabel';
import Button from '../../../components/core/Button';

interface EditChatbotProps {
  chatbot: {
    name: string;
    avatarImage: string;
    backgroundImage: string;
    description: string;
    key: string;
    maxTokens: number;
  };
  onUpdate: (updatedChatbot: any) => void;
  onCreateNewState: () => void;
}

const EditChatbot: React.FC<EditChatbotProps> = ({
  chatbot,
  onUpdate,
  onCreateNewState,
}) => {
  const [name, setName] = useState(chatbot.name);
  const [avatarImage, setAvatarImage] = useState(chatbot.avatarImage);
  const [backgroundImage, setBackgroundImage] = useState(
    chatbot.backgroundImage,
  );
  const [description, setDescription] = useState(chatbot.description);
  const [key, setKey] = useState(chatbot.key);
  const [maxTokens, setMaxTokens] = useState(chatbot.maxTokens);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onUpdate({
      name,
      avatarImage,
      backgroundImage,
      description,
      key,
      maxTokens,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="text-xl font-bold mb-5">Edit Chatbot</div>
      <InputWithLabel
        id="floatingName"
        label="Name"
        type="text"
        value={name}
        onChange={setName}
      />
      <InputWithLabel
        id="floatingAvatarImage"
        label="Avatar Image URL"
        type="text"
        value={avatarImage}
        onChange={setAvatarImage}
      />
      <InputWithLabel
        id="floatingBackgroundImage"
        label="Background Image URL"
        type="text"
        value={backgroundImage}
        onChange={setBackgroundImage}
      />
      <InputWithLabel
        id="floatingDescription"
        label="Description"
        type="text"
        value={description}
        onChange={setDescription}
      />
      <InputWithLabel
        id="floatingKey"
        label="Key"
        type="text"
        value={key}
        onChange={setKey}
      />
      <InputWithLabel
        id="floatingMaxTokens"
        label="Max Tokens"
        type="number"
        value={maxTokens.toString()}
        onChange={(value) => setMaxTokens(parseInt(value))}
      />
      <Button type="submit">Save Changes</Button>
      <Button onClick={() => onCreateNewState()}>Create New State</Button>
    </form>
  );
};

export { EditChatbot };


pages/admin/ChatBotEditingViews/EditChatbotProcessor.tsx:
import React, { useState, useEffect } from 'react';
import InputWithLabel from '../../../components/admin/InputWithLabel';
import Button from '../../../components/core/Button';
import { Select, initTE } from 'tw-elements';
import { SelectInput } from '../../../components/admin/SelectInput';
import {
  CloudArrowUpIcon,
  Cog6ToothIcon,
  MinusCircleIcon,
  PlusCircleIcon,
  TrashIcon,
} from '@heroicons/react/24/outline';
import { processorOptions } from './processorOptions';
import { TextareaWithLabel } from '../../../components/admin/TextareaWithLabel';
import { IconButton } from '../../../components/admin/IconButton';

interface EditChatbotProcessorProps {
  node: any;
  onUpdateProcessor: (updatedProcessor: any) => void;
  onDeleteProcessor: (processorId: string) => void;
  onInsertProcessorAfter: (processorId: string) => void;
}

const EditChatbotProcessor: React.FC<EditChatbotProcessorProps> = ({
  node,
  onUpdateProcessor,
  onDeleteProcessor,
  onInsertProcessorAfter,
}) => {
  const [processorData, setProcessorData] = useState<
    { key: string; value: string }[]
  >([]);
  const [processorName, setProcessorName] = useState<string>('');
  const [title, setTitle] = useState<string>(node.title || ''); // Add this line to keep track of title
  const [focused, setFocused] = useState<number | null>(null);
  const [setupMode, setSetupMode] = useState<boolean>(false);

  const toggleSetupMode = () => {
    setSetupMode(!setupMode);
  };

  useEffect(() => {
    const initialProcessorData = Object.entries(node.processor_data).map(
      ([key, value]) => ({
        key,
        value: value as string,
      }),
    );
    setProcessorData(initialProcessorData);
    setProcessorName(node.processor_name);
    setTitle(node.title || ''); // Add this line to update the title state when the node prop changes

    initTE({ Select });
  }, [node]);

  const handleKeyChange = (newValue: string, index: number) => {
    const updatedProcessorData = [...processorData];
    updatedProcessorData[index].key = newValue;
    setProcessorData(updatedProcessorData);
  };

  const handleValueChange = (newValue: string, index: number) => {
    if (newValue !== null) {
      const updatedProcessorData = [...processorData];
      updatedProcessorData[index].value = newValue;
      setProcessorData(updatedProcessorData);
    }
  };

  const addParam = () => {
    const newParam = { key: 'new_key', value: 'new_value' };
    setProcessorData([...processorData, newParam]);
  };

  const removeParam = (index: number) => {
    setProcessorData(processorData.filter((_, i) => i !== index));
  };

  const handleProcessorChange = (value: string) => {
    // Find the selected processor option
    const selectedProcessorOption = processorOptions.find(
      (option) => option.value === value,
    );

    // If the selected processor option has a processor_data preset, apply it
    if (selectedProcessorOption && selectedProcessorOption.processor_data) {
      const presetProcessorData = Object.entries(
        selectedProcessorOption.processor_data,
      ).map(([key, value]) => ({ key, value: String(value) })); // Convert value to string

      setProcessorData(presetProcessorData);
    }

    // Update the processorName
    setProcessorName(value);
  };

  const handleSave = () => {
    const updatedProcessorData = Object.fromEntries(
      processorData.map(({ key, value }) => [key, value]),
    );
    onUpdateProcessor({
      ...node,
      title, // Add the updated title here
      processor_name: processorName,
      processor_data: updatedProcessorData,
    });
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <div className="text-xl font-bold">Edit State Processor</div>
        <IconButton
          icon={<PlusCircleIcon className="w-6 h-6 text-stone-400" />}
          onClick={toggleSetupMode}
        />
        <IconButton
          icon={<TrashIcon className="w-6 h-6 text-stone-400" />}
          onClick={toggleSetupMode}
        />
        <IconButton
          icon={<CloudArrowUpIcon className="w-6 h-6 text-stone-400" />}
          onClick={toggleSetupMode}
        />
        <IconButton
          icon={
            <Cog6ToothIcon
              className={`${
                setupMode
                  ? ' w-6 h-6 text-orange-600'
                  : ' w-6 h-6 text-stone-400'
              } `}
            />
          }
          onClick={toggleSetupMode}
        />
      </div>

      <SelectInput
        options={processorOptions}
        value={processorName}
        onChange={(value) => handleProcessorChange(value)}
      />

      <InputWithLabel // Input for editing the title
        id="floatingTitle"
        label="Title"
        type="text"
        value={title}
        onChange={(newValue) => setTitle(newValue)}
      />

      {processorData.map(({ key, value }, index) => (
        <div key={key} className={`${setupMode ? 'flex space-x-2' : ''}`}>
          {setupMode ? (
            <>
              <InputWithLabel
                id={`processor_key_${key}`}
                label="Key"
                type="text"
                value={key}
                onChange={(newValue) => handleKeyChange(newValue, index)}
                onFocus={() => setFocused(index)}
                onBlur={() => setFocused(null)}
                autoFocus={focused === index}
              />
              <InputWithLabel
                id={`processor_value_${key}`}
                label="Value"
                type="text"
                value={value as string}
                onChange={(newValue) => handleValueChange(newValue, index)}
              />

              <button
                type="button"
                onClick={() => removeParam(index)}
                data-te-ripple-init
                data-te-ripple-color="light"
              >
                <MinusCircleIcon className="w-6 h-6 text-orange-400" />
              </button>
            </>
          ) : ['text', 'prompt', 'textarea', 'payload', 'headers'].includes(
              key,
            ) ? (
            <TextareaWithLabel
              id={`textarea_${key}`}
              label={key}
              rows={10}
              placeholder={'pls enter the prompt'}
              value={value}
              onChange={(updatedPrompt) =>
                handleValueChange(updatedPrompt, index)
              }
            />
          ) : (
            <InputWithLabel
              id="floatingName"
              label={key}
              type="text"
              value={value}
              onChange={(newValue) => handleValueChange(newValue, index)}
            />
          )}
        </div>
      ))}

      <Button onClick={handleSave}>Save</Button>
      <Button onClick={addParam}>Add Param</Button>
      <Button onClick={() => onDeleteProcessor(node._id)}>
        Delete Processor
      </Button>
      <Button onClick={() => onInsertProcessorAfter(node._id)}>
        Insert Processor After
      </Button>
    </div>
  );
};

export { EditChatbotProcessor };


pages/admin/ChatBotEditingViews/EditChatbotState.tsx:
import React, { useEffect, useState } from 'react';
import InputWithLabel from '../../../components/admin/InputWithLabel';
import Button from '../../../components/core/Button';
import { TextareaWithLabel } from '../../../components/admin/TextareaWithLabel';

interface EditChatbotStateProps {
  state: {
    _id: string;
    name: string;
    title?: string;
  };
  chatbotKey: string;
  onUpdateState: (updatedState: any) => void;
  onDeleteState: (stateId: string) => void;
  onSetActiveState: (stateId: string) => void;
  onAddProcessor: (stateId: string) => void;
}

const EditChatbotState: React.FC<EditChatbotStateProps> = ({
  state,
  chatbotKey,
  onUpdateState,
  onDeleteState,
  onSetActiveState,
  onAddProcessor,
}) => {
  const [name, setName] = useState(state.name);
  const [title, setTitle] = useState(state.title || ''); // New state for title

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onUpdateState({
      chatbotKey,
      _id: state._id,
      name,
      title, // Include the title in the updated state
      prompt,
    });
  };

  useEffect(() => {
    setName(state.name);
    setTitle(state.title || ''); // Update the title state when the state prop changes
    console.log('set title', state.title);
  }, [state]);

  return (
    <form onSubmit={handleSubmit}>
      <div className="text-xl font-bold mb-5">Edit Chatbot State</div>

      {/* Input for editing the title */}
      <InputWithLabel
        id="floatingTitle"
        label="Title"
        type="text"
        value={title}
        onChange={setTitle}
      />

      <InputWithLabel
        id="floatingName"
        label="Name"
        type="text"
        value={name}
        onChange={setName}
      />

      <div className="flex mt-2 content-stretch">
        <Button type="submit">Save</Button>
        <Button type="button" onClick={() => onDeleteState(state._id)}>
          Delete
        </Button>
        <Button type="button" onClick={() => onSetActiveState(state.name)}>
          Set Active
        </Button>
        <Button type="button" onClick={() => onAddProcessor(state._id)}>
          Add Processor
        </Button>
      </div>
    </form>
  );
};

export { EditChatbotState };


pages/admin/ChatBotEditingViews/processorOptions.tsx:
const processorOptions = [
  {
    value: 'response_to_ui',
    text: 'Response To UI',
    secondaryText: 'Map GPT response the relevant UI component (text, select)',
    processor_data: {
      type: 'text',
      modifyResponse: 1,
    },
  },
  {
    value: 'extract_json',
    text: 'Extract JSON',
    secondaryText: 'Extract JSON from the GPT response',
    processor_data: {
      modifyResponse: 1,
      saveResponseToSessionStore: 0,
    },
  },

  {
    value: 'rest_api',
    text: 'REST API Caller',
    secondaryText: 'Make a REST API call',
    processor_data: {
      api_url: 'https://api.example.com/data',
      http_method: 'GET',
      headers: { Authorization: 'Bearer YOUR_API_TOKEN' },
      payload: {},
      modifyResponse: 1,
      saveResponseToSessionStore: 0,
    },
  },

  {
    value: 'generate_images',
    text: 'Generate Images',
    secondaryText: 'Generate images using the GPT response',
    processor_data: {
      modifyResponse: 1,
      saveResponseToSessionStore: 0,
    },
  },
  {
    value: 'generate_video',
    text: 'Generate Video',
    secondaryText: 'Generate videos using the GPT response',
    processor_data: {
      modifyResponse: 1,
      saveResponseToSessionStore: 0,
    },
  },
  {
    value: 'gpt_query',
    text: 'GPT Query',
    secondaryText: 'Perform a query using the GPT model',
    processor_data: {
      key: 'gptKey',
      maxTokens: '800',
      maxHistoryMessages: '4',
      model: 'gpt-3.5-turbo',
      modifyResponse: 1,
      prompt:
        'based on the conversation, return an array with companies, tasks per company and log work per company in a JSON foramt',
      saveResponseToSessionStore: 0,
      temprature: '0.85',
      enableDebug: 0,
    },
  },
  {
    value: 'ner',
    text: 'NER - Named Entity Recognition',
    secondaryText: 'Perform Named Entity Recognition on the GPT response',
    processor_data: {
      key: 'nerKey',
      saveResponseToSessionStore: 1,
      modifyResponse: 0,
    },
  },
  {
    value: 'set_session_variable',
    text: 'Set Session Variable',
    secondaryText: 'Set a session variable based on the GPT response',
    processor_data: {
      nextProcessor: 'response_to_ui',
    },
  },
  {
    value: 'generate_audio',
    text: 'Generate Audio',
    secondaryText: 'Generate audio using the GPT response',
  },
  {
    value: 'generate_video_2',
    text: 'Generate Video',
    secondaryText:
      'Generate videos using the GPT response (alternative option)',
  },
  {
    value: 'query_index',
    text: 'Query Index',
    secondaryText: 'Query an index based on the GPT response',
  },
  {
    value: 'update_file',
    text: 'Update File',
    secondaryText: 'Update a file based on the GPT response',
  },
  {
    value: 'set_state',
    text: 'Set State',
    secondaryText: 'Set the state of the chatbot',
    processor_data: {
      newState: 'get_user_input',
    },
  },
];

export { processorOptions };


pages/admin/ChatbotView.tsx:
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useChatbot } from '../../custom-hooks/useChatbot';
import { ActionsView } from '../../components/admin/ActionsView/ActionsView';
import { ReactFlowProvider } from 'reactflow';
import { EditChatbot } from './ChatBotEditingViews/EditChatbot';
import { EditChatbotState } from './ChatBotEditingViews/EditChatbotState';
import { EditChatbotProcessor } from './ChatBotEditingViews/EditChatbotProcessor';
import { v4 as uuidv4 } from 'uuid';
import { SessionStoreView } from './SessionStoreView';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { Tab, initTE } from 'tw-elements';
import { Tabs } from '../../components/Tabs';
import { EditorSettingsView } from './EditorSettingsView';
import { Chat } from '../Chat';
import { Header } from '../../components/Header';
import { LoggerView } from './LoggerView';

const ChatbotView: React.FC = observer(() => {
  const { key } = useParams<{ key: string }>();
  const rootStore = useRootStore();
  const sessionIdOLD = rootStore.selectedChatSession?._id || '';

  const chatBotUpdateWrapper = async (updatedChatbot: Chatbot) => {
    await updateChatbot(updatedChatbot);

    if (key) {
      rootStore.setActiveChatbot(key);
    }
  };

  useEffect(() => {
    const loadData = async () => {
      if (rootStore.activeChatbot?.key) {
        await rootStore.loadChatSessions(rootStore.activeChatbot.key);
        rootStore.setActiveChatSession(rootStore.chatSessions[0]._id);
      }

      if (rootStore.chatbotsLoaded && key) {
        rootStore.setActiveChatbot(key);
      }
    };

    loadData();
    initTE({ Tab });
  }, [rootStore.activeChatbot?.key, rootStore.chatbotsLoaded, key]);

  const { chatbot, loading, error, updateChatbot } = useChatbot(
    key || '',
    sessionIdOLD || '',
  );

  const [selectedNode, setSelectedNode] = useState<{
    node: any;
    type: string;
  } | null>(null);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (error || !chatbot) {
    return <div>Chatbot not found</div>;
  }

  const handleNodeSelected = (data: any, type: string) => {
    setSelectedNode({ node: data, type });
  };

  const updateChatbotState = async (updatedData: any) => {
    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.map((state: any) => {
        if (state._id === updatedData._id) {
          return {
            ...updatedData,
            processors: state.processors,
          };
        }
        return state;
      }),
    };

    chatBotUpdateWrapper(updatedChatbot);
  };

  const updateChatbotProcessor = async (updatedProcessor: any) => {
    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.map((state: any) => {
        return {
          ...state,
          processors: state.processors.map((processor: any) => {
            if (processor._id === updatedProcessor._id) {
              return updatedProcessor;
            }
            return processor;
          }),
        };
      }),
    };
    chatBotUpdateWrapper(updatedChatbot);
  };

  const createNewState = async () => {
    const newState = {
      _id: uuidv4(),
      model: 'gpt-4',
      name: 'new-state-' + uuidv4(),
      processors: [],
      prompt: 'you\'re an ai .. ',
      temperature: 0.8,
    };

    const updatedChatbot = {
      ...chatbot,
      states: [...chatbot.states, newState],
    };

    chatBotUpdateWrapper(updatedChatbot);
  };

  const deleteChatbotState = async (stateId: string) => {
    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.filter((state: any) => state._id !== stateId),
    };
    chatBotUpdateWrapper(updatedChatbot);
  };

  const setActiveChatbotState = async (stateId: string) => {
    if (rootStore.selectedChatSession) {
      rootStore.setChatSessionState(
        rootStore.selectedChatSession?._id,
        stateId,
      );
      rootStore.selectedChatSession.setState(stateId);
      console.log('set active chatbot state', stateId);
    }
  };

  const addChatbotProcessor = async (stateId: string) => {
    const newProcessor = {
      _id: uuidv4(),
      processor_name: 'new-processor-' + uuidv4(),
      processor_data: {},
      type: 'processorNode',
    };

    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.map((state: any) => {
        if (state._id === stateId) {
          return {
            ...state,
            processors: [...state.processors, newProcessor],
          };
        }
        return state;
      }),
    };

    chatBotUpdateWrapper(updatedChatbot);
  };

  const deleteProcessor = async (processorId: string) => {
    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.map((state: any) => {
        return {
          ...state,
          processors: state.processors.filter(
            (processor: any) => processor._id !== processorId,
          ),
        };
      }),
    };
    chatBotUpdateWrapper(updatedChatbot);
  };

  const insertProcessorAfter = async (processorId: string) => {
    const newProcessor = {
      _id: uuidv4(),
      processor_name: 'new-processor-' + uuidv4(),
      processor_data: {},
    };

    const updatedChatbot = {
      ...chatbot,
      states: chatbot.states.map((state: any) => {
        const processorIndex = state.processors.findIndex(
          (processor: any) => processor._id === processorId,
        );

        if (processorIndex === -1) {
          return state;
        }

        const updatedProcessors = [
          ...state.processors.slice(0, processorIndex + 1),
          newProcessor,
          ...state.processors.slice(processorIndex + 1),
        ];

        return {
          ...state,
          processors: updatedProcessors,
        };
      }),
    };

    chatBotUpdateWrapper(updatedChatbot);
  };

  return (
    <>
      <div className="flex">
        <div className="w-2/3 bg-sky-100 border-r-2">
          <div className="w-full h-[42rem]">
            <ReactFlowProvider>
              <ActionsView
                chatbot={chatbot}
                onNodeSelected={handleNodeSelected}
              />
            </ReactFlowProvider>
          </div>
        </div>
        <div className="w-1/3 p-5 border-t-2">
          <Tabs
            tabs={[
              {
                id: 'tabs-home',
                label: 'Editor',
                content: (
                  <>
                    {selectedNode ? (
                      <>
                        {selectedNode.type === 'chatbotNode' && (
                          <EditChatbot
                            chatbot={selectedNode.node}
                            onUpdate={updateChatbot}
                            onCreateNewState={createNewState}
                          />
                        )}
                        {selectedNode.type === 'stateNode' && (
                          <EditChatbotState
                            state={selectedNode.node}
                            chatbotKey={chatbot.key}
                            onAddProcessor={addChatbotProcessor}
                            onUpdateState={updateChatbotState}
                            onDeleteState={deleteChatbotState}
                            onSetActiveState={setActiveChatbotState}
                          />
                        )}
                        {selectedNode.type === 'processorNode' && (
                          <EditChatbotProcessor
                            node={selectedNode.node}
                            onUpdateProcessor={updateChatbotProcessor}
                            onDeleteProcessor={deleteProcessor}
                            onInsertProcessorAfter={insertProcessorAfter}
                          />
                        )}
                      </>
                    ) : (
                      <div className="text-center text-gray-500 mt-5">
                        Please select a node to view or edit its details.
                      </div>
                    )}
                  </>
                ),
              },
              {
                id: 'tabs-profile',
                label: 'Store',
                content: <SessionStoreView />,
              },
              {
                id: 'tabs-log',
                label: 'Log',
                content: <LoggerView />,
              },
              {
                id: 'tabs-messages',
                label: 'Settings',
                content: <EditorSettingsView />,
              },
              {
                id: 'tabs-chat',
                label: 'Run',
                content: (
                  <div className=" border-secondary-100 border-2 ">
                    <Header
                      onMenuClick={() => console.log('on menu click')}
                      forceShow={true}
                    />
                    <div
                      style={{
                        maxHeight: '850px',
                        overflowY: 'auto',
                        display: 'flex',
                        flexDirection: 'column',
                        justifyContent: 'flex-end',
                      }}
                    >
                      <Chat />
                    </div>
                  </div>
                ),
              },
            ]}
          />
        </div>
      </div>
    </>
  );
});

export { ChatbotView };


pages/admin/CompaniesPage.tsx:
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { Table } from '../../components/Table';
import { toJS } from 'mobx';
import { withPage } from '../../components/admin/HOC/withPage';
import { convertToStringArray } from '../../utils/utils';
import { PlayIcon, TrashIcon } from '@heroicons/react/24/outline';
import { IconButton } from '../../components/admin/IconButton';
import { emitter } from '../../services/mittEmitter';
import { EVENT_SHOW_ADD_COMPANY_MODAL } from '../../utils/eventNames';
import { CompanyKeys, ICompany } from '../../store/models/Company';
import {
  LOCALSTORAGE_COMPANY_ID,
  LOCALSTORAGE_USER_ID,
  getLocalStorageItem,
  getSessionById,
  setLocalStorageItem,
  createSession,
} from '../../services/api/sessionService';
import { TagsInput } from '../../components/InputTags';

const CompaniesView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const navigate = useNavigate();

  const headers: CompanyKeys[] = ['name', 'openai_api_key'];

  const handleDelete = (row: ICompany) => {
    rootStore.deleteCompany(row._id);
  };

  const handleSetCompany = async (row: ICompany) => {
    setLocalStorageItem(LOCALSTORAGE_COMPANY_ID, row._id);

    const session = await createSession(
      getLocalStorageItem(LOCALSTORAGE_USER_ID) || '',
      row._id
    );

    const sessionData = await getSessionById(session._id);
    rootStore.sessionStore.setActiveSession(sessionData);

    rootStore.loadAssistants();
    rootStore.loadInboxMessages();

    // emitter.emit(EVENT_SHOW_NOTIFICATION, 'Company set successfully');
  };

  const Actions = (row: ICompany) => (
    <div className="flex space-x-3 items-center mx-1">
      <IconButton
        icon={<TrashIcon className="w-5 h-5  text-warning-900" />}
        onClick={(event) => {
          event.stopPropagation();
          handleDelete(row);
        }}
      />
      <IconButton
        icon={<PlayIcon className="w-5 h-5  text-warning-900" />}
        onClick={(event) => {
          event.stopPropagation();
          handleSetCompany(row);
        }}
      />
    </div>
  );

  return (
    <>
      <TagsInput
        title="Actions"
        description="Select actions to perform on selected rows"
        selectedTags={[]}
        availableTags={[
          {
            id: 'add-user',
            name: 'add-user',
          },
          {
            id: 'remove-user',
            name: 'remove-user',
          },
        ]}
      />
      <div className="flex w-full justify-center">
        <div className=" flex-auto">
          <Table
            headers={convertToStringArray(headers)}
            data={toJS(rootStore.companies)}
            onRowClick={(row: ICompany) =>
              navigate(`/admin/companies/${row._id}`)
            }
            Actions={Actions}
          />
        </div>
        <div className=" flex-0 w-96"></div>
      </div>
    </>
  );
});

const CompaniesPage = withPage('Comapnies', 'list of companies', () => {
  emitter.emit(EVENT_SHOW_ADD_COMPANY_MODAL, 'Add Company');
})(CompaniesView);
export { CompaniesPage };


pages/admin/Dashboard.tsx:
import React, { useState } from 'react';
import { ContentContainer } from '../../components/ContentContainer';
import { useEffect } from 'react';
// import { Chatbot, fetchChatbots } from "../../services/ChatbotService";
import  {Menu }  from '../../components/admin/Menu';
import { ChatbotCard } from '../../components/admin/chatbots/ChatbotCard';
import { ChatSessionCard } from '../../components/admin/chatSessions/ChatSessionCard';
import { BreadCrumbs } from '../../components/BreadCrumbs';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';

const Dashboard = observer(() => {
  // const [chatSessions, setChatSessions] = useState<ChatSession[]>([]);
  const { chatbots } = useRootStore();

  // useEffect(() => {

  //   async function fetchSessionsData() {
  //     const sessions = await fetchChatSessions();
  //     // setChatSessions(sessions);
  //   }

  //   fetchSessionsData();
  // }, []);

  return (
    <>
      <div className="text-2xl font-normal leading-tight mb-4">
        Chatbots {chatbots.length}
      </div>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3 mb-3">
        {chatbots.map((chatbot) => (
          <ChatbotCard key={chatbot.key} chatbot={chatbot} />
        ))}
      </div>
    </>
  );
});

export { Dashboard };


pages/admin/EditAssistantPage.tsx:
import React from 'react'; // Add this line

import { useParams } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { IAssistant } from '../../store/models/Assistant';
import { withPage } from '../../components/admin/HOC/withPage';
import {
  DynamicForm,
  FieldConfig,
  FormValues,
} from '../../components/DynamicForm';
import { toJS } from 'mobx';
import { assistantFieldConfigs } from '../../store/fieldConfigs/assistantFieldConfigs';

const EditAssistantView: React.FC = observer(() => {
  const { key } = useParams<{ key: string }>();
  const rootStore = useRootStore();
  const assistant = key ? rootStore.getAssistantById(key) : null;
  const [isLoading, setIsLoading] = React.useState(false);

  if (rootStore.assistantsLoaded === false) {
    return <div>Loading...</div>;
  }

  if (!assistant) {
    return <div>Assistant not found</div>;
  }

  const formFields: FieldConfig[] = assistantFieldConfigs.map(
    ({ id, label, key, type, visibility }) => {
      const fieldKeyString = String(key);
      return {
        key: key,
        label: label,
        value: assistant ? toJS((assistant as any)[fieldKeyString]) : '',
        id: id,
        type: type,
        visibility: visibility,
      };
    }
  );

  const handleSubmit = async (values: FormValues) => {
    console.log('Form Values:', values);
    if (!key) {
      return;
    }
    setIsLoading(true);
    await rootStore.updateAssistant(key, values as unknown as IAssistant);
    setIsLoading(false);
  };

  return (
    <>
      <div className="flex w-full">
        <div className="w-1/2">
          <DynamicForm
            fields={formFields}
            onSubmit={handleSubmit}
            isLoading={isLoading}
            formType="update"
          />
        </div>
        <div className="w-1/2">Test your assistant here</div>
      </div>
    </>
  );
});

const EditAssistantPage = withPage(
  'Edit AI Assistant',
  'update your ai agents here', 
  () => { console.log('edit assistant');}
)(EditAssistantView);
export { EditAssistantPage, EditAssistantView };


pages/admin/EditCompanyPage.tsx:
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { ICompany } from '../../store/models/Company';
import { withPage } from '../../components/admin/HOC/withPage';
import { DynamicForm, FieldConfig, FormValues } from '../../components/DynamicForm';
import { toJS } from 'mobx';
import { companyFieldConfigs } from '../../store/fieldConfigs/companyFieldConfigs'; // Assuming similar structure as assistantFieldConfigs

const EditCompanyView: React.FC = observer(() => {
  const { id } = useParams<{ id: string }>();
  const rootStore = useRootStore();
  const company = id ? rootStore.getCompanyById(id) : null;
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!rootStore.companiesLoaded) {
      // Logic to load companies if not already loaded
    }
  }, [rootStore]);

  if (rootStore.companiesLoaded === false) {
    return <div>Loading...</div>;
  }

  if (!company) {
    return <div>Company not found</div>;
  }

  const formFields: FieldConfig[] = companyFieldConfigs.map(({ id, label, key, type, visibility }) => {
    const fieldKeyString = String(key);
    return {
      key: key,
      label: label,
      value: company ? toJS((company as any)[fieldKeyString]) : '',
      id: id,
      type: type,
      visibility: visibility,
    };
  });

  const handleSubmit = async (values: FormValues) => {
    console.log('Form Values:', values);
    if (!id) {
      return;
    }
    setIsLoading(true);
    await rootStore.updateCompany(id, values as unknown as ICompany);
    setIsLoading(false);
  };

  return (
    <>
      <div className="flex w-full">
        <div className="w-1/2">
          <DynamicForm
            fields={formFields}
            onSubmit={handleSubmit}
            isLoading={isLoading}
            formType="update"
          />
        </div>
        <div className="w-1/2">
          {/* Additional UI or functionality related to company can be added here */}
        </div>
      </div>
    </>
  );
});

const EditCompanyPage = withPage(
  'Edit Company',
  'Update company details here',
  () => { console.log('edit company'); }
)(EditCompanyView);

export { EditCompanyPage, EditCompanyView };


pages/admin/EditorSettingsView.tsx:
import React, { useEffect, useState } from 'react';
import { LabelText } from '../../components/chat/LabelText';
import { IconButton } from '../../components/admin/IconButton';
import { ArrowPathIcon, TrashIcon } from '@heroicons/react/24/outline';
import { useRootStore } from '../../store/common/RootStoreContext';
import { SelectInput } from '../../components/admin/SelectInput';
import { observer } from 'mobx-react-lite';
import { autorun } from 'mobx';
import {
  ClipboardDocumentCheckIcon,
  LinkIcon,
  PlusIcon,
} from '@heroicons/react/24/solid';

interface EditorSettingsProps {}
interface ProcessorOption {
  value: string;
  text: string;
  secondaryText: string;
}

const EditorSettingsView: React.FC<EditorSettingsProps> = observer(() => {
  const { chatSessions, createChatSession, loadChatSessions } = useRootStore();
  const EditorfetchAndSetSettings = async () => {};
  const rootStore = useRootStore();

  const copySessionIdToClipboard = () => {
    navigator.clipboard.writeText(rootStore.selectedChatSession?._id || '');
  };

  const openSessionInNewTab = () => {
    window.open(
      `http://localhost:5173/chat/${rootStore.selectedChatSession?._id}`,
      '_blank',
    );
  };

  useEffect(() => {
    EditorfetchAndSetSettings();
  }, []);

  const HandleAddSession = async () => {
    await createChatSession();
  };

  const EditorreloadSettings = () => {
    EditorfetchAndSetSettings();
  };

  const [processorOptions, setProcessorOptions] = useState<ProcessorOption[]>(
    [],
  );

  const [selectedProcessor, setSelectedProcessor] = useState('');

  useEffect(() => {
    autorun(() => {
      const options = chatSessions.map((session) => ({
        value: session._id,
        text: session.user_id,
        secondaryText: session.current_state,
      }));
      setProcessorOptions(options);
    });
  }, [chatSessions]);

  return (
    <div className="p-2">
      <div className="flex justify-between items-center mb-2">
        <h2 className="text-xl font-bold">Chat Sessions</h2>{' '}
        <div className="">
          <IconButton
            icon={<PlusIcon className="w-5 h-5 text-sky-800" />}
            onClick={HandleAddSession}
          />
        </div>
      </div>

      <div className="flex flex-col mt-5 text-slate-400">
        <SelectInput
          options={processorOptions}
          value={selectedProcessor}
          onChange={(value: string) => {
            setSelectedProcessor(value);
            const selectedSession = chatSessions.find(
              (session) => session._id === value,
            );
            if (selectedSession) {
              rootStore.setActiveChatSession(selectedSession._id);
            }
          }}
        />
        <div className="mb-2 flex justify-between items-center text-sm rounded-md ">
          <div>{rootStore.selectedChatSession?._id}</div>
          <div>
            <IconButton
              icon={
                <ClipboardDocumentCheckIcon className="w-5 h-5 text-slate-800" />
              }
              onClick={copySessionIdToClipboard}
            />
            <IconButton
              icon={<LinkIcon className="w-5 h-5 text-slate-800 ml-2" />}
              onClick={openSessionInNewTab}
            />
          </div>
        </div>
      </div>
    </div>
  );
});

export { EditorSettingsView };


pages/admin/JSONView.tsx:
import ReactJson from 'react18-json-view';

interface JSONViewProps {
  json: string | object | number;
}

const JSONView: React.FC<JSONViewProps> = ({ json }) => {
  let parsedJson;
  let isJson = true;
  let jsonString;
  let isJsonObject = true;

  try {
    if (typeof json === 'string') {
      parsedJson = JSON.parse(json);
      jsonString = json;
      isJsonObject = typeof parsedJson === 'object';
    } else if (typeof json === 'number') {
      // If the input is a number, convert it to string
      parsedJson = json;
      jsonString = json.toString();
      isJsonObject = false;
    } else {
      parsedJson = json;
      jsonString = JSON.stringify(json);
      isJsonObject = typeof parsedJson === 'object';
    }
  } catch (e) {
    // In case of a parse error, it's not valid JSON
    isJson = false;
    jsonString =
      typeof json === 'object' ? JSON.stringify(json) : json.toString();
  }

  return isJson && isJsonObject ? (
    <ReactJson src={parsedJson} theme="default" enableClipboard={false} />
  ) : (
    <pre className="text-xs overflow-auto bg-neutral-50 dark:bg-neutral-700 rounded-lg whitespace-pre-wrap">
      {jsonString}
    </pre>
  );
};

export { JSONView };


pages/admin/LoggerView.tsx:
import React, { useEffect, useState } from 'react';
import { IconButton } from '../../components/admin/IconButton';
import { observer } from 'mobx-react-lite';
import {
  ArrowLeftOnRectangleIcon,
  ArrowRightOnRectangleIcon,
  BoltIcon,
  ChatBubbleLeftEllipsisIcon,
  GlobeAltIcon,
  PauseCircleIcon,
  TrashIcon,
} from '@heroicons/react/24/outline';
import { DataItem } from '../../components/admin/DataItem';
import { LogItem } from '../../components/admin/LogItem';

import Pusher from 'pusher-js';
import {
  ArrowPathRoundedSquareIcon,
  CodeBracketIcon,
  CommandLineIcon,
  PaintBrushIcon,
  RocketLaunchIcon,
} from '@heroicons/react/24/solid';
import { JSONView } from './JSONView';

const pusher = new Pusher('7e8897731876adb4652f', {
  cluster: 'eu',
});

interface LoggerViewProps {}

const LoggerView: React.FC<LoggerViewProps> = observer(() => {
  const [logs, setLogs] = useState<
    Array<{
      icon: React.ReactNode;
      title: string;
      name: string;
      input: string;
      output?: string;
      status: string;
      indent?: boolean;
      isDebugLog?: boolean; // New variable
    }>
  >([]);

  const clearLogs = () => {
    setLogs([]);
  };

  useEffect(() => {
    const channel = pusher.subscribe('logger');
    channel.bind('log-message', function (data: any) {
      console.log(`Received log message: ${JSON.stringify(data, null, 2)}`); // Log the data here

      if (!data.name || !data.input) {
        console.error(`Invalid log message: ${JSON.stringify(data, null, 2)}`);
        return;
      }

      let icon: React.ReactNode;
      let indent: boolean;
      let isDebugLog: boolean = false; // Additional variable to track if it's a debug log

      switch (data.name) {
        case 'user_input':
          icon = <RocketLaunchIcon className="w-4 h-4" />;
          indent = false;
          break;
        case 'gpt_query':
          icon = <BoltIcon className="w-4 h-4" />;
          indent = true;
          break;
        case 'rest_api':
          icon = <GlobeAltIcon className="w-4 h-4" />;
          indent = true;
          break;

        case 'gpt_query_debug': // New case
          icon = <BoltIcon className="w-4 h-4" />;
          indent = true;
          isDebugLog = true; // Set it as debug log
          break;
        case 'set_state':
          icon = <CodeBracketIcon className="w-4 h-4" />;
          indent = true;
          break;
        case 'response_to_ui':
          icon = <CommandLineIcon className="w-4 h-4" />;
          indent = true;
        case 'extract_json':
          icon = <ArrowPathRoundedSquareIcon className="w-4 h-4" />;
          indent = true;
          break;
        case 'generate_images':
          icon = <PauseCircleIcon className="w-4 h-4" />;
          indent = true;
          break;
        default:
          console.error(`Unsupported log message name: ${data.name}`);
          return;
      }

      const newLog = {
        icon,
        name: data.name,
        title: data.title,
        input: data.input, // Don't stringify here
        output: data.output, // Don't stringify here
        status:
          typeof data.status === 'boolean'
            ? data.status
              ? 'success'
              : 'failed'
            : data.status,
        indent,
        isDebugLog,
      };

      setLogs((prevLogs) => [...prevLogs, newLog]);
    });
  }, []);

  return (
    <div className="p-2">
      <div className="flex justify-between items-center mb-2">
        <h2 className="text-xl font-bold">Logger</h2>{' '}
        <div className="">
          <IconButton
            icon={<TrashIcon className="w-5 h-5 text-sky-800" />}
            onClick={clearLogs}
          />
        </div>
      </div>

      <div className="flex flex-col mt-8 text-slate-400">
        <ol className="border-l-2 border-info-100">
          {logs.map((log, index) => (
            <LogItem
              key={index}
              name={log.name}
              icon={log.icon}
              title={log.title}
              input={<JSONView json={log.input} />} // Use JSONView here
              output={<JSONView json={log.output || ''} />} // Use JSONView here
              status={log.status}
              indent={log.indent}
              isDebugLog={log.isDebugLog} // Pass the isDebugLog to LogItem
            />
          ))}
        </ol>
      </div>
    </div>
  );
});

export { LoggerView };


pages/admin/SessionStoreView.tsx:
import React, { useEffect, useState } from 'react';
import { LabelText } from '../../components/chat/LabelText';
import {
  deleteSessionStore,
  fetchSessionStore,
} from '../../services/SessionStoreService';
import { SessionStore } from '../../services/SessionStoreService';
import { IconButton } from '../../components/admin/IconButton';
import { ArrowPathIcon, TrashIcon } from '@heroicons/react/24/outline';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';

interface SessionStoreProps {}

const SessionStoreView: React.FC<SessionStoreProps> = observer(() => {
  const [sessionStore, setSessionStore] = useState<SessionStore | null>(null);
  const { selectedChatSession, chatSessionsLoaded } = useRootStore();

  const fetchAndSetSessionStore = async () => {
    if (selectedChatSession) {
      const sessionStore = await fetchSessionStore(selectedChatSession._id);
      setSessionStore(sessionStore);

      console.log('sessionStore', sessionStore);
    }
  };

  useEffect(() => {
    fetchAndSetSessionStore();
  }, [selectedChatSession]);

  if (!sessionStore) {
    return <div>Loading...</div>;
  }

  const clearSessionStore = async () => {
    if (selectedChatSession) {
      try {
        const result = await deleteSessionStore(selectedChatSession._id);
        console.log(result);
        setSessionStore(null); // clear the sessionStore state
      } catch (error) {
        console.error('Failed to delete session store:', error);
      }
    }
  };

  const reloadSessionStore = () => {
    fetchAndSetSessionStore();
  };

  return (
    <div className="p-2">
      <div className="flex justify-between items-center mb-2">
        <h2 className="text-xl font-bold">Session Store</h2>{' '}
        <div className="mr-2">
          <IconButton
            icon={<TrashIcon className="w-5 h-5 text-sky-800 mr-4" />}
            onClick={clearSessionStore}
          />
          <IconButton
            icon={<ArrowPathIcon className="w-5 h-5 text-sky-800" />}
            onClick={reloadSessionStore}
          />
        </div>
      </div>

      <LabelText
        label={<div className="text-xs mr-4 text-sky-700 ">id</div>}
        text={<div className={' text-sm'}>{sessionStore.sessionId}</div>}
        layout="horizontal"
      />
      <div className="mt-5">
        {Object.entries(sessionStore).map(([key, value]) => {
          const displayValue = JSON.stringify(value, null, 2);

          return (
            <div key={key} className=" bg-primary-300 mb-4 rounded-lg p-3">
              <LabelText
                label={
                  <div className="text-sm mb-1 mr-5 text-sky-100">{key}</div>
                }
                text={<div className={'text-base'}>{displayValue}</div>}
                labelVerticalAlign="center"
                layout="vertical"
              />
            </div>
          );
        })}
      </div>
    </div>
  );
});

export { SessionStoreView };


pages/admin/SessionsPage.tsx:
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { Table } from '../../components/Table';
import { toJS } from 'mobx';
import { withPage } from '../../components/admin/HOC/withPage';
import { convertToStringArray } from '../../utils/utils';
import {  
  PlayIcon,
  TrashIcon,
} from '@heroicons/react/24/outline';
import { IconButton } from '../../components/admin/IconButton';
import { SessionKeys, ISession } from '../../store/models/Session';
import { EVENT_SHOW_NOTIFICATION } from '../../utils/eventNames';
import { emitter } from '../../services/mittEmitter';

const SessionsView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const navigate = useNavigate();

  const headers: SessionKeys[] = [ 'companyName' , 'userName', 'assistantName' ,  'threadId', 'active'];

  const handleDelete = (row: ISession) => {    
    rootStore.sessionStore.deleteSession(row._id);
  };

  const handleSetActiveSession = (row: ISession) => {
    rootStore.sessionStore.setActiveSessionById(row._id);
    emitter.emit(EVENT_SHOW_NOTIFICATION, 'Session set successfully');
  };

  const Actions = (row: ISession) => (
    <div className="flex space-x-3 items-center mx-1">
      <IconButton
        icon={<TrashIcon className="w-5 h-5 text-warning-900 hover:text-warning-700" />}
        onClick={(event) => {
          event.stopPropagation();
          handleDelete(row);
        }}
      />
      <IconButton
        icon={
          <PlayIcon className="w-5 h-5 text-warning-900 hover:text-lime-600" />
        }
        onClick={(event) => {
          event.stopPropagation();
          handleSetActiveSession(row);
        }}
      />
    </div>
  );

  return (
    <>
      <div className="flex w-full justify-center">
        <div className=" flex-auto">
          <Table
            headers={convertToStringArray(headers)}
            data={toJS(rootStore.sessionStore.sessions)}
            onRowClick={(row: ISession) =>
              navigate(`/admin/sessions/${row._id}`)
            }
            Actions={Actions}
          />
        </div>
        <div className=" flex-0 w-96">
          {/* Additional UI elements can be added here */}
        </div>
      </div>
    </>
  );
});

const SessionsPage = withPage(
  'Sessions',
  'list of sessions',
  () => {
    // emitter.emit(EVENT_SHOW_ADD_SESSION_MODAL, 'Add Session');
  }
)(SessionsView);
export { SessionsPage };


pages/admin/UsersPage.tsx:
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../store/common/RootStoreContext';
import { Table } from '../../components/Table';
import { toJS } from 'mobx';
import { UserKeys, IUser } from '../../store/models/User';
import { withPage } from '../../components/admin/HOC/withPage';
import { convertToStringArray } from '../../utils/utils';
import { PlayIcon, TrashIcon } from '@heroicons/react/24/outline';
import { IconButton } from '../../components/admin/IconButton';
import { emitter } from '../../services/mittEmitter';
import { EVENT_SHOW_ADD_USER_MODAL, EVENT_SHOW_NOTIFICATION } from '../../utils/eventNames';
import { LOCALSTORAGE_COMPANY_ID, LOCALSTORAGE_USER_ID, getLocalStorageItem, setLocalStorageItem, createSession, getSessionById } from '../../services/api/sessionService';
// import { EVENT_SHOW_ADD_USER_MODAL } from '../../utils/eventNames';

const UsersView: React.FC = observer(() => {
  const rootStore = useRootStore();
  const navigate = useNavigate();

  const headers: UserKeys[] = ['name', 'nickname'];

  const handleDelete = (row: IUser) => {
    rootStore.deleteUser(row._id);
  };

  const handleSetUser = async (row: IUser) => {
    
    setLocalStorageItem(LOCALSTORAGE_USER_ID, row._id);

    const session = await createSession(      
      row._id,
      getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) || '',
    );

    const sessionData = await getSessionById(session._id);
    rootStore.sessionStore.setActiveSession(sessionData);
    emitter.emit(EVENT_SHOW_NOTIFICATION, 'User set successfully');
    
  };

  const Actions = (row: IUser) => (
    <div className="flex space-x-3 items-center mx-1">
      <IconButton
        icon={<TrashIcon className="w-5 h-5  text-warning-900" />}
        onClick={(event) => {
          event.stopPropagation();
          handleDelete(row);
        }}
      />
      <IconButton
        icon={<PlayIcon className="w-5 h-5  text-warning-900" />}
        onClick={(event) => {
          event.stopPropagation();
          handleSetUser(row);
        }}
      />

    </div>
  );

  return (
    <>
      <div className="flex w-full justify-center">
        <div className="flex-auto">
          <Table
            headers={convertToStringArray(headers)}
            data={toJS(rootStore.users)}
            onRowClick={(row: IUser) => navigate(`/admin/users/${row._id}`)}
            Actions={Actions}
          />
        </div>
        <div className="flex-0 w-96">
          {/* Additional UI elements can be added here */}
        </div>
      </div>
    </>
  );
});

const UsersPage = withPage(
  'Users',
  'manage your users here',
  () => {
    emitter.emit(EVENT_SHOW_ADD_USER_MODAL, 'Add User');
  }
)(UsersView);
export { UsersPage };


pages/admin/inbox/InboxMessage.tsx:
import React from 'react';
import { ChatBubbleLeftIcon, UserIcon, BellIcon } from '@heroicons/react/24/outline';
import { IMessage } from '../../../store/models/Inbox';
import moment from 'moment';

interface InboxMessageProps {
  message: IMessage;
}

// Helper function to return the icon component with the styled div container
const getIconComponent = (message: IMessage) => {
  switch (message.type) {
    case 'human_agent_request':
      return (
        <div className="rounded-full bg-blue-100 border p-1">
          <ChatBubbleLeftIcon className="w-5 h-5 text-gray-800" />
        </div>
      );
    case 'human_agent_response':
      return (
        <div className="rounded-full bg-green-100 border p-1">
          <UserIcon className="w-5 h-5 text-gray-800" />
        </div>
      );
    case 'notification':
      return (
        <div className="rounded-full bg-yellow-100 border p-1">
          <BellIcon className="w-5 h-5 text-gray-800" />
        </div>
      );
    default:
      return (
        <div className="rounded-full bg-gray-100 border p-1">
          <ChatBubbleLeftIcon className="w-5 h-5 text-gray-800" />
        </div>
      );
  }
};

const InboxMessage: React.FC<InboxMessageProps> = ({ message }) => {
  const iconComponent = getIconComponent(message);

  return (
    <div className="flex gap-3 my-4 text-gray-600 text-sm" key={message._id}>
      <span className="flex shrink-0 overflow-hidden rounded-full w-8 h-8">
        {iconComponent}
      </span>
      <div>
        <p className="font-bold text-gray-800">
          {message.type === 'human_agent_response' ? 'Support Reviewer' : (message.assistantName || 'Unknown')}
        </p>
        <p className="leading-relaxed">{message.message}</p>
        <p className="text-xs text-gray-500">
          {moment(message.createdAt).fromNow()}
        </p>
      </div>
    </div>
  );
};

export { InboxMessage };


pages/admin/inbox/InboxPage.tsx:
import React, { useEffect, useState } from 'react';
import { observer } from 'mobx-react-lite';
import { withPage } from '../../../components/admin/HOC/withPage';
import { emitter } from '../../../services/mittEmitter';
import { EVENT_SHOW_ADD_USER_MODAL } from '../../../utils/eventNames';
import { IInboxSession, IMessage } from '../../../store/models/Inbox';
import { useRootStore } from '../../../store/common/RootStoreContext';
import { autorun } from 'mobx';
import { InboxMessage } from './InboxMessage';
import { SessionInfo } from './SessionInfo';
import { addInboxResponse } from '../../../services/api/inboxService';

const DisplayMessages: React.FC<{ session: IInboxSession }> = ({ session }) => {
  return (
    <>
      {session.messages.map((message: IMessage) =>
        InboxMessage({ message: message })
      )}
    </>
  );
};

const InboxView: React.FC = observer(() => {

  const rootStore = useRootStore();

  const [selectedSession, setSelectedSession] = useState<IInboxSession | null>(
    null
  );
  const [message, setMessage] = useState('');
  const [ isLoading, setIsLoading ] = useState(false); 

  const handleSendMessage = async () => {

    setIsLoading(true);
    const sessionId = selectedSession?.sessionId;

    if (!sessionId) {
      setIsLoading(false);
      console.error('No session selected');
      return;
    }

    try {
      const response = await addInboxResponse(sessionId, message);
      console.log('Message sent successfully', response);
      setMessage('');
      setIsLoading(false); 
    } catch (error) {
      console.error('Failed to send message', error);
      setIsLoading(false); 
    }
  };

  useEffect(() => {
    const dispose = autorun(() => {
      if (rootStore.inboxSessions.length > 0) {
        setSelectedSession(rootStore.inboxSessions[0]);
      }
    });
    return () => dispose();
  }, [rootStore.inboxSessions]);

  return (
    <>
      <div className="flex w-full justify-center">
        <main className="flex w-full h-full ">
          <section className="flex flex-col w-4/12  h-full overflow-y-scroll border-r-2 border-sky-100">
            <label className="px-2">
              <input
                className="rounded-lg p-4 bg-gray-200 transition duration-200 focus:outline-none focus:ring-2 w-full"
                placeholder="Search..."
              />
            </label>

            <ul className="mt-4">
              {rootStore.inboxSessions.length > 0 &&
                rootStore.inboxSessions.map((session) => (
                  <SessionInfo
                    key={session.sessionId}
                    session={session}
                    onClick={() => setSelectedSession(session)}
                    isActive={selectedSession?.sessionId === session.sessionId}
                  />
                ))}
            </ul>
          </section>
          <section className="w-8/12 px-4 flex flex-col ">
            <div className="flex justify-between items-center border-b-2 mb-4 pb-4">
              <div className="flex space-x-4 items-center">
                {selectedSession && selectedSession.messages.length > 0 && (
                  <div className="flex flex-col">
                    <h3 className="font-semibold text-lg">
                      {selectedSession.messages[0].userName}
                    </h3>
                    <p className="text-light text-gray-400">
                      topic of the session / short intro
                    </p>
                  </div>
                )}
              </div>
            </div>

            {selectedSession && <DisplayMessages session={selectedSession} />}

            <section className="mt-6 border rounded-xl bg-gray-50 mb-3">
              <textarea
                className="w-full bg-gray-50 p-2 rounded-xl disabled:text-slate-400"
                placeholder="Type your reply here..."
                rows={3}
                disabled={isLoading}
                value={message}
                onChange={(e) => setMessage(e.target.value)}
              ></textarea>
              <div className="flex items-center justify-between p-2">
                <button className="h-6 w-6 text-gray-400">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"
                    />
                  </svg>
                </button>
                <button
                  onClick={handleSendMessage}
                  disabled={isLoading}
                  className="bg-purple-600 text-white px-6 py-2 rounded-xl disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Reply
                </button>
              </div>
            </section>
          </section>
        </main>
      </div>
    </>
  );
});

const InboxPage = withPage(
  'Inbox',
  'manage communication with your users here',
  () => {
    emitter.emit(EVENT_SHOW_ADD_USER_MODAL, 'Add User');
  }
)(InboxView);
export { InboxPage };


pages/admin/inbox/SessionInfo.tsx:
import React  from 'react';
import { IInboxSession } from '../../../store/models/Inbox';
import moment from 'moment';

export interface SessionInfoProps {
  session: IInboxSession;
  isActive: boolean;
  onClick: () => void;
}

export const SessionInfo: React.FC<SessionInfoProps> = ({
  session,
  isActive,
  onClick,
}) => {
  const activeClass = isActive ? 'bg-sky-100' : '';

  return (
    <li
      key={session.sessionId}
      className={`py-3 px-3 transition hover:bg-indigo-100 cursor-pointer ${activeClass}`}
      onClick={onClick}
    >
      <div className="flex justify-between items-center">
        <h3 className="font-semibold text-sm">
          {session.messages[session.messages.length - 1].userName}
        </h3>
        <p className="text-xs text-gray-500">
          {moment(
            session.messages[session.messages.length - 1].createdAt
          ).fromNow()}
        </p>
      </div>
      <div className="text-sm text-gray-500">
        {session.messages[session.messages.length - 1].message}
      </div>
    </li>
  );
};


services/AudioService.ts:
const playAudioBase64 = (base64Data: string) => {
  return new Promise<void>((resolve, reject) => {
    const audioData = atob(base64Data);
    const arrayBuffer = new ArrayBuffer(audioData.length);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < audioData.length; i++) {
      view[i] = audioData.charCodeAt(i);
    }
    const blob = new Blob([arrayBuffer], { type: 'audio/mp3' });
    const audio = new Audio(URL.createObjectURL(blob));

    audio.play().catch((e) => {
      console.log('error playing audio', e);
      reject(e);
    });

    audio.addEventListener('ended', () => {
      resolve();
    });
  });
};

const playAudio = async (audioFile?: ArrayBuffer) => {
  if (audioFile) {
    return playAudioBase64(audioFile.toString());
  }

  return Promise.reject('No audio file provided.');
};

export { playAudio };


services/BaseRowService.ts:
import axios from 'axios';

interface ChatBotAPIResponse {
  key: string;
  name: string;
  description: string;
  autoTranslate: boolean;
  autoTranslateTarget: string;
  ttsLanguage: string;
  ttsActor: string;
  temperature: number;
  avatar: {
    url: string;
    thumbnails: {
      tiny: {
        url: string;
        width: number | null;
        height: number;
      };
      small: {
        url: string;
        width: number;
        height: number;
      };
      card_cover: {
        url: string;
        width: number;
        height: number;
      };
    };
    visible_name: string;
    name: string;
    size: number;
    mime_type: string;
    is_image: boolean;
    image_width: number;
    image_height: number;
    uploaded_at: string;
  }[];
  bgImage: {
    url: string;
    thumbnails: {
      tiny: {
        url: string;
        width: number | null;
        height: number;
      };
      small: {
        url: string;
        width: number;
        height: number;
      };
      card_cover: {
        url: string;
        width: number;
        height: number;
      };
    };
    visible_name: string;
    name: string;
    size: number;
    mime_type: string;
    is_image: boolean;
    image_width: number;
    image_height: number;
    uploaded_at: string;
  }[];
  prompt: string;
  logo: {
    url: string;
    thumbnails: {
      tiny: {
        url: string;
        width: number | null;
        height: number;
      };
      small: {
        url: string;
        width: number;
        height: number;
      };
      card_cover: {
        url: string;
        width: number;
        height: number;
      };
    };
    visible_name: string;
    name: string;
    size: number;
    mime_type: string;
    is_image: boolean;
    image_width: number;
    image_height: number;
    uploaded_at: string;
  }[];
}

const mapChatBot = (chatBot: ChatBotAPIResponse) => {
  return {
    key: chatBot.key,
    name: chatBot.name,
    description: chatBot.description,
    avatar: chatBot?.avatar[0]?.url,
    bgImage: chatBot?.bgImage[0]?.url,
    prompt: chatBot.prompt,
    logo: chatBot?.logo[0]?.url,
    autoTranslate: chatBot.autoTranslate,
    autoTranslateTarget: chatBot.autoTranslateTarget,
    ttsLanguage: chatBot.ttsLanguage,
    ttsActor: chatBot.ttsActor,
    temperature: Number(chatBot.temperature),
  };
};

const fetchContextData = async (key: string) => {
  try {
    const response = await axios({
      method: 'GET',
      url:
        'https://api.baserow.io/api/database/rows/table/142027/?user_field_names=true&&filter__field_925007__equal=' +
        key,
      headers: {
        Authorization: 'Token xYNbZuE6CN4KarOStEiUnMqQTU920uw6',
      },
    });
    return response.data.results;
  } catch (error) {
    console.error(error);
    return [];
  }
};

const fetchChatBots = async () => {
  try {
    const response = await axios({
      method: 'GET',
      url: 'https://api.baserow.io/api/database/rows/table/141893/?user_field_names=true',
      headers: {
        Authorization: 'Token xYNbZuE6CN4KarOStEiUnMqQTU920uw6',
      },
    });
    return response.data.results.map(mapChatBot);
  } catch (error) {
    console.error(error);
    return [];
  }
};

export { fetchChatBots, fetchContextData };


services/ChatService.ts:
import {
  ContextData,
  getMessageTextGPT,
  Message,
} from '../atoms/dataStore-old';
import Mustache from 'mustache';
import axios from 'axios';

const getGPTResponse = async (sessionId: string, message: string) => {
  const response = await axios.post(
    `http://127.0.0.1:5000/chat_sessions/${sessionId}/messages`,
    {
      content: message,
    },
  );
  return response.data;
};

const deleteMessageFromSession = async (
  sessionId: string,
  messageId: string,
) => {
  const response = await axios.delete(
    `http://127.0.0.1:5000/chat_sessions/${sessionId}/messages/${messageId}`,
  );
  return response.data;
};

const getSessionMessages = async (sessionId: string) => {
  const response = await axios.get(
    `http://127.0.0.1:5000/chat_sessions/${sessionId}/messages`,
  );
  return response.data;
};

const clearSession = (sessionId: string) => {
  return axios.delete(
    `http://127.0.0.1:5000/chat_sessions/${sessionId}/messages`,
  );
};

const getGPTCompletion = async (
  promptTemplate: string,
  sessionId: string,
  userName: string,
  message: string,
  history: Message[],
  temperature: number,
) => {
  const tmp = await getGPTResponse(sessionId, message);
  return tmp;
  // return tmp.response;
};

const getSession = async (sessionId: string) => {
  const response = await axios.get(
    `http://127.0.0.1:5000/chat_sessions/${sessionId}`,
  );
  return response.data;
};

export {
  getGPTCompletion,
  clearSession,
  getSessionMessages,
  getSession,
  deleteMessageFromSession,
};


services/ChatSessionView.tsx:
// src/pages/ChatSessionView.tsx

import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';

interface ChatSessionData {
  chatbot: any;
  messages: any[];
}

const ChatSessionView: React.FC = () => {
  const [chatSessionData, setChatSessionData] =
    useState<ChatSessionData | null>(null);
  const { id } = useParams<{ id: string }>();

  useEffect(() => {
    fetch(`http://127.0.0.1:5000/chat_sessions/${id}`)
      .then((response) => response.json())
      .then((data) => {
        setChatSessionData(data);
      });
  }, [id]);

  return (
    <div className="p-4">
      {chatSessionData ? (
        <>
          <h1 className="text-3xl mb-4">Chat Session: {id}</h1>
          <h2 className="text-xl mb-4">Chatbot Information</h2>
          <div>
            <p>Name: {chatSessionData.chatbot.name}</p>
            <p>Description: {chatSessionData.chatbot.description}</p>
            <p>Avatar Image URL: {chatSessionData.chatbot.avatarImage}</p>
          </div>
          <h2 className="text-xl mb-4 mt-8">Messages</h2>
          <ul>
            {chatSessionData.messages.map((message, index) => (
              <li key={index}>
                <p>
                  <strong>{message.role}: </strong>
                  {message.content}
                </p>
                <p>{message.created_at}</p>
              </li>
            ))}
          </ul>
        </>
      ) : (
        <p>Loading chat session data...</p>
      )}
    </div>
  );
};

export { ChatSessionView };


services/DialogFactory.ts:
import { NewAssistantView } from '../pages/NewAssistantView';
import { NewCompanyView } from '../pages/NewCompanyView';
import { NewUserView } from '../pages/NewUserView';
import {
  EVENT_SHOW_ADD_ASSISTANT_MODAL,
  EVENT_SHOW_ADD_COMPANY_MODAL,
  EVENT_SHOW_ADD_USER_MODAL,
  EventType,
} from '../utils/eventNames';
import React from 'react';

export interface DialogComponentEventData {
  title: string;
  component: React.ReactElement;
}

const dialogComponentFactory = (
  eventType: EventType,
  eventData: DialogComponentEventData
): { title: string; component: React.ReactElement } => {
  switch (eventType) {
    case EVENT_SHOW_ADD_ASSISTANT_MODAL:
      return {
        title: eventData.title || 'Create New Assistant',
        component: React.createElement(NewAssistantView),
      };

    case EVENT_SHOW_ADD_COMPANY_MODAL:
      return {
        title: eventData.title || 'Create New Company',
        component: React.createElement(NewCompanyView),
      };

    case EVENT_SHOW_ADD_USER_MODAL:
      return {
        title: eventData.title || 'Create New User',
        component: React.createElement(NewUserView),
      };

    default:
      return {
        title: '',
        component: React.createElement('div', {}, 'test'),
      };
  }
};

export { dialogComponentFactory };


services/PusherService.ts:
import Pusher from 'pusher-js';

const pusher = new Pusher('7e8897731876adb4652f', {
    cluster: 'eu',
});

export { pusher };

services/SessionStoreService.tsx:
export interface SessionStore {
  _id: string;
  data: any;
  sessionId: string;
}

export async function deleteSessionStore(sessionId: string): Promise<any> {
  const response = await fetch(
    `http://127.0.0.1:5000/session_store/${sessionId}`,
    {
      method: 'DELETE',
    },
  );
  const result = await response.json();
  return result;
}

export async function fetchSessionStore(
  sessionId: string,
): Promise<SessionStore> {
  const response = await fetch(
    `http://127.0.0.1:5000/session_store/${sessionId}`,
  );
  const sessionStore = await response.json();
  return sessionStore;
}


services/TTSService.ts:
import axios, { AxiosResponse } from 'axios';
const apiKeyForGoogle = 'AIzaSyChUGpxx9shF3dckbeNdR7frcwcuZ4VrGg';

interface Input {
  text: string;
}

interface Voice {
  languageCode: string;
  name: string;
}

interface AudioConfig {
  audioEncoding: string;
}

interface RequestBody {
  input: Input;
  voice: Voice;
  audioConfig: AudioConfig;
}

const generateAudioFromText = (
  text: string,
  languageCode: string,
  voiceName: string,
): Promise<ArrayBuffer> => {
  const trimmedText = text.substring(0, 80);

  const requestBody: RequestBody = {
    // input: { text },
    input: { text: trimmedText },
    voice: { languageCode, name: voiceName },
    audioConfig: { audioEncoding: 'MP3' },
  };

  const headers = {
    'Content-Type': 'application/json; charset=utf-8',
  };

  const config = {
    headers,
  };

  const url = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKeyForGoogle}`;

  return axios
    .post<ArrayBuffer>(url, requestBody, config)
    .then((response: AxiosResponse<any>) => {
      return response.data.audioContent;
    });
};

export { generateAudioFromText };


services/TranslationService.ts:
import axios from 'axios';
// import sanitizeHtml from 'sanitize-html';

interface TranslateResponse {
  data: {
    translations: [
      {
        translatedText: string;
      },
    ];
  };
}

export const translateText = async (
  text: string,
  targetLanguage: string,
): Promise<string> => {
  const response = await axios.get<TranslateResponse>(
    'https://translation.googleapis.com/language/translate/v2',
    {
      params: {
        q: text,
        target: targetLanguage,
        key: 'AIzaSyCmCIWBPBwiYiwHa0KoiL892ucEhRy8hZ8',
        // key: process.env.REACT_APP_GOOGLE_TRANSLATE_API_KEY,
      },
    },
  );

  return response.data.data.translations[0].translatedText;
  // return sanitizeHtml(response.data.data.translations[0].translatedText);
};


services/api/actionService.ts:
import axios from 'axios';
import { IAction } from '../../store/models/Action';


const BASE_URL = 'http://localhost:3000/action';

export const getActions = async (): Promise<IAction[]> => {
  const response = await axios.get(BASE_URL);
  return response.data;
};

export const addAction = async (action: IAction): Promise<IAction> => {
  const response = await axios.post(BASE_URL, action);
  return response.data;
};

export const deleteAction = async (actionId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/${actionId}`);
};

export const updateAction = async (actionId: string, action: IAction): Promise<IAction> => {
  const response = await axios.put(`${BASE_URL}/${actionId}`, action);
  return response.data;
};

export const getActionById = async (actionId: string): Promise<IAction> => {
  const response = await axios.get(`${BASE_URL}/${actionId}`);
  return response.data;
};

services/api/assistantService.ts:
import axios from 'axios';
import { IAssistant } from '../../store/models/Assistant';

export async function addThread(): Promise<string> {
  try {
    const newThread = await axios.post('http://localhost:3000/assistant/thread');    
    return newThread.data;
  } catch (error) {
    console.error('Failed to add thread:', error);
    throw error;
  }
}

export async function getThreadMessages(threadId: string): Promise<any> {
  try {
    const response = await axios.get(`http://localhost:3000/assistant/thread/${threadId}/messages`);
    return response.data;
  } catch (error) {
    console.error('Failed to get thread messages:', error);
    throw error;
  }
}

export async function getSessionMessages(companyId: string, userId: string): Promise<any> {
  try {
    const response = await axios.get(`http://localhost:3000/session/messages/${companyId}/${userId}`);
    return response.data;
  } catch (error) {
    console.error('Failed to get session messages:', error);
    throw error;
  }
}

export async function deleteThread(threadId: string): Promise<void> {
  try {
    await axios.delete(`http://localhost:3000/assistant/thread/${threadId}`);
  } catch (error) {
    console.error('Failed to delete thread:', error);
    throw error;
  }
}

export async function endSession(companyId: string, userId: string): Promise<void> {
  try {
    await axios.delete(`http://localhost:3000/session/end/${companyId}/${userId}`);
  } catch (error) {
    console.error('Failed to end session:', error);
    throw error;
  }
}

interface HandleUserInputBody {
  userInput: string;
  companyId: string;
  userId: string;
}

export async function handleUserInput(body: HandleUserInputBody): Promise<string> {
  try {
    const response = await axios.post('http://localhost:3000/assistant/user-input', body);
    return response.data;
  } catch (error) {
    console.error('Failed to handle user input:', error);
    throw error;
  }
}


export async function getAssistants(companyId : string): Promise<IAssistant[]> {
  try {    
    const response = await axios.get(`http://localhost:3000/assistant/company/${companyId}`);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch assistants:', error);
    throw error;
  }
}

export async function deleteAssistant(id: string): Promise<void> {
  try {
    await axios.delete(`http://localhost:3000/assistant/${id}`);
  } catch (error) {
    console.error('Failed to delete assistant:', error);
    throw error;
  }
}

export async function addAssistant(assistant: IAssistant): Promise<IAssistant> {
  try {
    const response = await axios.post('http://localhost:3000/assistant', assistant);
    return response.data;
  } catch (error) {
    console.error('Failed to add assistant:', error);
    throw error;
  }
}

export async function updateAssistant(id: string, assistant: IAssistant): Promise<IAssistant> {
  try {
    const response = await axios.put(`http://localhost:3000/assistant/${id}`, assistant);
    return response.data;
  } catch (error) {
    console.error('Failed to update assistant:', error);
    throw error;
  }
}

services/api/chatSessionService.ts:
import {
  ChatSessionSnapshotIn,
  IChatSession,
} from '../../store/models/ChatSession';
const API_URL = 'http://127.0.0.1:5000';

interface ICreateChatSessionData {
  user_id: string;
  chatbot_key: string;
}

export async function getChatSessions(
  chatbot_key: string,
): Promise<IChatSession[]> {
  const response = await fetch(
    `${API_URL}/chat_sessions?chatbot_key=${chatbot_key}`,
  );
  const chatSessions = await response.json();
  return chatSessions;
}

export async function createChatSession(
  data: ICreateChatSessionData,
): Promise<ChatSessionSnapshotIn> {
  const response = await fetch(`${API_URL}/chat_sessions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data),
  });

  const result = await response.json();

  if (response.ok) {
    return {
      _id: result.chat_session_id,
      chatbot_key: data.chatbot_key,
      user_id: data.user_id,
      created_at: new Date(),
      updated_at: new Date(),
      active: true,
      current_state: 'NEW', // Or whatever the initial state should be
    };
  } else {
    throw new Error('Failed to create chat session');
  }
}

export async function getChatSessionById(id: string): Promise<IChatSession> {
  const response = await fetch(`http://127.0.0.1:5000/chat_sessions/${id}`);
  const chatSession = await response.json();
  return chatSession;
}

export async function setChatSessionState(
  sessionId: string,
  state: string,
): Promise<void> {
  const response = await fetch(
    `${API_URL}/chat_sessions/${sessionId}/set_state`,
    {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ state }),
    },
  );

  if (!response.ok) {
    throw new Error(
      `Failed to set chat session state! status: ${response.status}`,
    );
  }
}


services/api/chatbotService.ts:
import { IChatbot } from '../../store/models/Chatbot';

export async function getChatbots(): Promise<IChatbot[]> {
  const response = await fetch('http://127.0.0.1:5000/chatbots');
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const chatbots: IChatbot[] = await response.json();
  return chatbots;
}


services/api/companyService.ts:
import axios from 'axios';
import { ICompany } from '../../store/models/Company';

export const getCompanies = async (): Promise<ICompany[]> => {
  try {
    const response = await axios.get('http://localhost:3000/company');
    return response.data;
  } catch (error) {
    console.error('Failed to fetch companies', error);
    throw error;
  }
};

export const addCompany = async (company: ICompany): Promise<ICompany> => {
  try {
    const response = await axios.post('http://localhost:3000/company', company);
    return response.data;
  } catch (error) {
    console.error('Failed to add company', error);
    throw error;
  }
};

export const deleteCompany = async (companyId: string): Promise<void> => {
  try {
    await axios.delete(`http://localhost:3000/company/${companyId}`);
  } catch (error) {
    console.error('Failed to delete company', error);
    throw error;
  }
};

export const updateCompany = async ( _id : string, company: ICompany): Promise<ICompany> => {
  try {
    const response = await axios.put(`http://localhost:3000/company/${_id}`, company);
    return response.data;
  } catch (error) {
    console.error('Failed to update company', error);
    throw error;
  }
}

services/api/inboxService.ts:
import axios from 'axios';
import { IInboxSession } from '../../store/models/Inbox';

export const getInboxMessages = async (companyId: string) : Promise<IInboxSession[]> => {
  try {
    const response = await axios.get(`http://localhost:3000/inbox/${companyId}`);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch inbox messages', error);
    throw error;
  }
};

export const addInboxMessage = async (sessionId: string, message: string) : Promise<IInboxSession> => {
  try {
    const response = await axios.post(`http://localhost:3000/inbox/${sessionId}`, { message });
    return response.data;
  } catch (error) {
    console.error('Failed to add inbox message', error);
    throw error;
  }
};


export const addInboxResponse = async (sessionId: string, message: string) : Promise<IInboxSession> => {
  try {
    const response = await axios.post(`http://localhost:3000/inbox/reply/${sessionId}`, { message });
    return response.data;
  } catch (error) {
    console.error('Failed to add inbox response', error);
    throw error;
  }
};


services/api/sessionService.ts:
import axios from 'axios';
import { ISession } from '../../store/models/Session';

export const LOCALSTORAGE_USER_ID = 'userId';
export const LOCALSTORAGE_COMPANY_ID = 'companyId';

export type LocalStorageKeys =
  | typeof LOCALSTORAGE_USER_ID
  | typeof LOCALSTORAGE_COMPANY_ID

export const getLocalStorageItem = (key: LocalStorageKeys): string | null => {
  return localStorage.getItem(key);
}

export const setLocalStorageItem = (key: LocalStorageKeys, value: string): void => {
  return localStorage.setItem(key, value);
}

export const getCompanyId = (): string | null => {
  return getLocalStorageItem(LOCALSTORAGE_COMPANY_ID);
};

export const getUserId = (): string | null => {
  return getLocalStorageItem(LOCALSTORAGE_USER_ID);
};

export const setCompanyId = (companyId: string): void => {
  setLocalStorageItem(LOCALSTORAGE_COMPANY_ID, companyId);
};

export const setUserId = (userId: string): void => {
  setLocalStorageItem(LOCALSTORAGE_USER_ID, userId);
};

export const updateSessionAssistant = async (
  sessionId: string,
  assistantId: string
): Promise<void> => {
  try {
    await axios.put(`http://localhost:3000/session/${sessionId}`, {
      assistantId,
    });
  } catch (error) {
    console.error(`Failed to update assistant for session with id ${sessionId}`, error);
    throw error;
  }
};


export const createSession = async (
  userId: string,
  companyId: string,
  assistantId?: string
): Promise<ISession> => {
  try {
    const response = await axios.post('http://localhost:3000/session', {
      userId,
      companyId,
      assistantId,
    });
    return response.data;
  } catch (error) {
    console.error(
      `Failed to update session for user ${userId} and company ${companyId}`,
      error
    );
    throw error;
  }
};

export const getAllSessions = async (companyId: string): Promise<ISession[]> => {
  try {
    const response = await axios.get(`http://localhost:3000/session/friendly/${companyId}`);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch sessions', error);
    throw error;
  }
};

export const getSessionByCompanyAndUserId = async (
  companyId: string,
  userId: string
): Promise<ISession> => {
  try {
    const response = await axios.get(
      `http://localhost:3000/session/${companyId}/${userId}`
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch session for user ${userId} and company ${companyId}`,
      error
    );
    throw error;
  }
}

export const getSessionById = async (sessionId: string): Promise<ISession> => {
  try {
    const response = await axios.get(
      `http://localhost:3000/session/${sessionId}`
    );
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch session with id ${sessionId}`, error);
    throw error;
  }
};

export const deleteSession = async (sessionId: string): Promise<void> => {
  try {
    await axios.delete(`http://localhost:3000/session/${sessionId}`);
  } catch (error) {
    console.error(`Failed to delete session with id ${sessionId}`, error);
    throw error;
  }
};


services/api/userService.ts:
import axios from 'axios';
import { IUser } from '../../store/models/User';

const baseUrl = 'http://localhost:3000/user';

export const getAllUsers = async (): Promise<IUser[]> => {
  try {
    const response = await axios.get(baseUrl);
    return response.data;
  } catch (error) {
    console.error('Failed to fetch users', error);
    throw error;
  }
};

export const getUserById = async (userId: string): Promise<IUser> => {
  try {
    const response = await axios.get(`${baseUrl}/${userId}`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch user with id ${userId}`, error);
    throw error;
  }
};

export const addUser = async (userData: IUser): Promise<IUser> => {
  try {
    const response = await axios.post(baseUrl, userData);
    return response.data;
  } catch (error) {
    console.error('Failed to create user', error);
    throw error;
  }
};

export const deleteUser = async (userId: string): Promise<void> => {
  try {
    await axios.delete(`${baseUrl}/${userId}`);
  } catch (error) {
    console.error(`Failed to delete user with id ${userId}`, error);
    throw error;
  }
};


services/mittEmitter.ts:
import mitt from 'mitt';
import { useEffect } from 'react';
export const emitter = mitt();

export const useEventEmitter = <T>(eventName: string, handler: (event: T) => void) => {
  useEffect(() => {
    const typedHandler = (event: unknown) => handler(event as T);
    emitter.on(eventName, typedHandler);
    return () => emitter.off(eventName, typedHandler);
  }, [eventName, handler]);
};



services/useTimer.ts:
import { useRef, useState } from 'react';

const useTimer = (sendMessage: () => void) => {
  const [timerRunning, setTimerRunning] = useState(false);
  const timerRef = useRef<number | null>(null);

  function startTimer() {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    timerRef.current = window.setTimeout(() => {
      sendMessage();
      setTimerRunning(false);
    }, 4000);
    setTimerRunning(true);
  }

  function resetTimer() {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      setTimerRunning(false);
    }
  }

  return { timerRunning, startTimer, resetTimer };
};

export { useTimer };


store/common/RootStoreContext.ts:
import { createContext, useContext } from 'react';
import { Instance } from 'mobx-state-tree';
import { RootStore } from '../models/RootStore';

const RootStoreContext = createContext<Instance<typeof RootStore> | null>(null);

export const RootStoreProvider = RootStoreContext.Provider;

export const useRootStore = () => {
  const store = useContext(RootStoreContext);
  if (store === null) {
    throw new Error('Store cannot be null, please add a context provider');
  }
  return store;
};

export default RootStoreContext;


store/fieldConfigs/assistantFieldConfigs.ts:
import { FieldConfig } from '../../components/DynamicForm';

export const assistantFieldConfigs: FieldConfig[] = [
  {
    id: 'assistantId',
    label: 'Assistant ID',
    key: 'assistantId',
    type: 'input',
    value: '-',
    visibility: { create: false, view: true, update: true },
  },
  {
    id: 'name',
    label: 'Name',
    key: 'name',
    type: 'input',
    value: 'New Assistant',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'description',
    key: 'description',
    label: 'Description',
    type: 'textarea',
    value: 'New Assistant Description',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'introMessage',
    key: 'introMessage',
    label: 'Intro Message',
    type: 'input',
    value: 'New Assistant Intro Message',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'voice',
    key: 'voice',
    label: 'Voice',
    type: 'input',
    value: 'Polly.Emma',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'language',
    key: 'language',
    label: 'Language',
    type: 'input',
    value: 'en-US',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'llmModel',
    key: 'llmModel',
    label: 'LLM Model',
    type: 'input',
    value: 'gpt-3.5-turbo-1106',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'llmPrompt',
    key: 'llmPrompt',
    label: 'LLM Prompt',
    type: 'textarea',
    value:
      'You are chatting with an AI assistant. The assistant is helpful, creative, clever, and very friendly.',
    visibility: { create: true, view: true, update: true },
  }
];


store/fieldConfigs/companyFieldConfigs.ts:
import { FieldConfig } from '../../components/DynamicForm';

export const companyFieldConfigs: FieldConfig[] = [
  {
    id: 'name',
    label: 'Name',
    key: 'name',
    type: 'input',
    value: 'New Company',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'openai_api_key',
    key: 'openai_api_key',
    label: 'Intro openai_api_key',
    type: 'input',
    value: 'New Assistant Intro Message',
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'identifiers',
    key: 'identifiers',
    label: 'Identifiers',
    type: 'key-value-list',
    value: [
      {
        key: 'phone',
        value: '+972xxxxxxxxx',
      },
    ],
    visibility: { create: true, view: true, update: true },
  }
];


store/fieldConfigs/userFieldConfigs.ts:
import { FieldConfig } from '../../components/DynamicForm';

export const userFieldConfigs: FieldConfig[] = [
  {
    id: 'name',
    key: 'name',
    label: 'Name',
    type: 'input',
    value: 'Bob Smith', // Default value for name
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'nickname',
    key: 'nickname',
    label: 'Nickname',
    type: 'input',
    value: 'Bob', // Default value for nickname
    visibility: { create: true, view: true, update: true },
  },
  {
    id: 'identifiers',
    key: 'identifiers',
    label: 'Identifiers',
    type: 'key-value-list',
    value: [
      {
        key: 'phone',
        value: '+972xxxxxxxxx',
      },
    ],
    visibility: { create: true, view: true, update: true },
  },  
];


store/models/Action.ts:
import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';

const Action = types.model('Action', {
  _id: types.identifier,
  name: types.string,
  description: types.string,
  type: types.string,
  parameters: types.string,
});

type IAction = Instance<typeof Action>;
type ActionSnapshotIn = SnapshotIn<typeof Action>;
type ActionSnapshotOut = SnapshotOut<typeof Action>;

export type ActionKeys = keyof IAction;
export { Action };
export type { IAction, ActionSnapshotIn, ActionSnapshotOut };


store/models/Assistant.ts:
import {
  types,
  Instance,
  SnapshotIn,
  SnapshotOut,
} from 'mobx-state-tree';

const Identifier = types.model('Identifier', {
  _id: types.optional(types.identifier, '-'),
  key: types.string,
  value: types.string,
});

const Assistant = types.model('Assistant', {
  _id: types.identifier,
  assistantId: types.string,
  name: types.string,
  description: types.string,
  introMessage: types.string,
  companyId: types.string,
  voice: types.string,
  language: types.string,  
  llmModel: types.optional(types.string, ''),
  llmPrompt: types.optional(types.string, ''),
});

type IAssistant = Instance<typeof Assistant>;
type AssistantSnapshotIn = SnapshotIn<typeof Assistant>;
type AssistantSnapshotOut = SnapshotOut<typeof Assistant>;
export type AssistantKeys = keyof IAssistant;

export { Assistant, Identifier };
export type { IAssistant, AssistantSnapshotIn, AssistantSnapshotOut };


store/models/Company.ts:
import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';
import { Identifier } from './Assistant';

const Company = types.model('Company', {
  _id: types.identifier,
  name: types.string,
  openai_api_key: types.string,
  identifiers: types.optional(types.array(Identifier), []),
  __v: types.number,
});

type ICompany = Instance<typeof Company>;
type CompanySnapshotIn = SnapshotIn<typeof Company>;
type CompanySnapshotOut = SnapshotOut<typeof Company>;
export type CompanyKeys = keyof ICompany;

export { Company };
export type { ICompany, CompanySnapshotIn, CompanySnapshotOut };


store/models/Inbox.ts:
import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';

// Define MessageType enum
const MessageType = types.enumeration('MessageType', [
  'human_agent_request',
  'human_agent_response',
  'notification'
]);

// Update Message model
const Message = types.model('Message', {
  _id: types.identifier,
  message: types.string,
  createdAt: types.maybeNull(types.string), // Use 'maybe' for optional fields
  userName: types.optional(types.string, ''),
  sessionActive: types.boolean,
  assistantName: types.maybeNull(types.string),
  assistantId: types.maybeNull(types.string),
  type: MessageType, // Add the new 'type' field
});

const InboxSession = types.model('InboxSession', {
  sessionId: types.identifier,
  messages: types.array(Message),
});

type IMessage = Instance<typeof Message>;
type IInboxSession = Instance<typeof InboxSession>;
type MessageSnapshotIn = SnapshotIn<typeof Message>;
type InboxSessionSnapshotIn = SnapshotIn<typeof InboxSession>;
type MessageSnapshotOut = SnapshotOut<typeof Message>;
type InboxSessionSnapshotOut = SnapshotOut<typeof InboxSession>;

export { Message, InboxSession };
export type { IMessage, IInboxSession, MessageSnapshotIn, InboxSessionSnapshotIn, MessageSnapshotOut, InboxSessionSnapshotOut };


store/models/RootStore.ts:
import { types, flow, applySnapshot, Instance } from 'mobx-state-tree';
import { Assistant, IAssistant } from './Assistant';
import {
  addAssistant,
  deleteAssistant,
  getAssistants,
  updateAssistant,
} from '../../services/api/assistantService';
import { emitter } from '../../services/mittEmitter';
import {
  EVENT_CLOSE_MODAL,
  EVENT_ERROR,
  EVENT_SHOW_NOTIFICATION,
} from '../../utils/eventNames';
import { Company, ICompany } from './Company';
import {
  addCompany,
  deleteCompany,
  getCompanies,
  updateCompany,
} from '../../services/api/companyService';
import {
  LOCALSTORAGE_COMPANY_ID,
  getLocalStorageItem,
} from '../../services/api/sessionService';
import { IUser, User } from './User';
import {
  addUser,
  deleteUser,
  getAllUsers,
} from '../../services/api/userService';
import { SessionStore } from './SessionStore';
import { getInboxMessages } from '../../services/api/inboxService';
import { InboxSession } from './Inbox';
import { Action, IAction } from './Action';
import {
  addAction,
  deleteAction,
  getActions,
  updateAction,
} from '../../services/api/actionService';

const RootStore = types
  .model('RootStore', {
    assistants: types.array(Assistant),
    companies: types.array(Company),
    companiesLoaded: types.optional(types.boolean, false),
    users: types.array(User),
    assistantsLoaded: types.optional(types.boolean, false),
    sessionStore: types.optional(SessionStore, {}),

    inboxSessions: types.array(InboxSession),
    inboxSessionsLoaded: types.optional(types.boolean, false),

    actions: types.array(Action),
    actionsLoaded: types.optional(types.boolean, false),
  })
  .actions((self) => ({
    loadActions: flow(function* () {
      try {
        const actions = yield getActions();
        applySnapshot(self.actions, actions);
        self.actionsLoaded = true;
      } catch (error) {
        console.error('Failed to load actions', error);
      }
    }),
    addAction: flow(function* (action: IAction) {
      try {
        const newAction = yield addAction(action);
        self.actions.push(newAction);
        emitter.emit(EVENT_SHOW_NOTIFICATION, 'Action added successfully');
      } catch (error) {
        console.error('Failed to add action', error);
      }
    }),
    updateAction: flow(function* (actionId: string, action: IAction) {
      try {
        const updatedAction = yield updateAction(actionId, action);
        const index = self.actions.findIndex((act) => act._id === actionId);
        if (index !== -1) {
          self.actions[index] = updatedAction;
          emitter.emit(EVENT_SHOW_NOTIFICATION, 'Action updated successfully');
        }
      } catch (error) {
        console.error('Failed to update action', error);
      }
    }),
    deleteAction: flow(function* (actionId: string) {
      try {
        yield deleteAction(actionId);
        self.actions.replace(
          self.actions.filter((act) => act._id !== actionId)
        );
        emitter.emit(EVENT_SHOW_NOTIFICATION, 'Action deleted successfully');
      } catch (error) {
        console.error('Failed to delete action', error);
      }
    }),

    loadInboxMessages: flow(function* () {
      try {
        const inboxMessages = yield getInboxMessages(
          self.sessionStore.activeSession?.companyId || ''
        );
        applySnapshot(self.inboxSessions, inboxMessages);
        self.inboxSessionsLoaded = true;
      } catch (error) {
        console.error('Failed to load inboxMessages', error);
      }
    }),

    loadAssistants: flow(function* () {
      try {
        const assistants = yield getAssistants(
          getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) || ''
        );
        applySnapshot(self.assistants, assistants);
        self.assistantsLoaded = true;
      } catch (error) {
        console.error('Failed to load assistants', error);
      }
    }),

    loadCompanies: flow(function* () {
      try {
        const companies = yield getCompanies();
        applySnapshot(self.companies, companies);
        self.companiesLoaded = true; // Set this to true after loading companies
      } catch (error) {
        console.error('Failed to load companies', error);
      }
    }),

    getCompanyById: (_id: string) => {
      return self.companies.find((company) => company._id === _id);
    },
    updateCompany: flow(function* (_id: string, company: ICompany) {
      try {
        const updatedCompany = yield updateCompany(_id, company);
        const index = self.companies.findIndex((comp) => comp._id === _id);
        if (index !== -1) {
          self.companies[index] = updatedCompany;
          emitter.emit(
            EVENT_SHOW_NOTIFICATION,
            'Company has been updated successfully'
          );
        }
      } catch (error) {
        console.error('Failed to update company', error);
      }
    }),

    loadUsers: flow(function* () {
      try {
        const users = yield getAllUsers();
        applySnapshot(self.users, users);
      } catch (error) {
        console.error('Failed to load assistants', error);
      }
    }),

    addUser: flow(function* (user: IUser) {
      try {
        const newUser = yield addUser(user);
        self.users.push(newUser);
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'New user has been created successfully'
        );

        emitter.emit(EVENT_CLOSE_MODAL); // Emit the close modal event
      } catch (error: any) {
        console.error('Failed to create user', error);
        emitter.emit(EVENT_ERROR, 'Failed to add user: ' + error.message);
      }
    }),

    deleteUser: flow(function* (_id: string) {
      try {
        yield deleteUser(_id);
        const index = self.users.findIndex((user) => user._id === _id);
        if (index !== -1) {
          self.users.splice(index, 1);
        }
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'User has been deleted successfully'
        );
      } catch (error) {
        console.error('Failed to delete user', error);
      }
    }),

    addCompany: flow(function* (company: ICompany) {
      try {
        const newCompany = yield addCompany(company);
        self.companies.push(newCompany);
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'New company has been created successfully'
        );
        emitter.emit(EVENT_CLOSE_MODAL); // Emit the close modal event
      } catch (error: any) {
        console.error('Failed to create company', error);
        emitter.emit(EVENT_ERROR, 'Failed to add company: ' + error.message);
      }
    }),

    deleteCompany: flow(function* (_id: string) {
      try {
        yield deleteCompany(_id);
        const index = self.companies.findIndex(
          (company) => company._id === _id
        );
        if (index !== -1) {
          self.companies.splice(index, 1);
        }
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'Company has been deleted successfully'
        );
      } catch (error) {
        console.error('Failed to delete assistant', error);
      }
    }),

    createAssistant: flow(function* (assistant: IAssistant) {
      try {
        // set companyId to activeSession companyId
        assistant.companyId =
          getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) || '';
        const newAssistant = yield addAssistant(assistant);
        self.assistants.push(newAssistant);
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'New assistant has been created successfully'
        );
        emitter.emit(EVENT_CLOSE_MODAL); // Emit the close modal event
      } catch (error: any) {
        console.error('Failed to create assistant', error);
        emitter.emit(EVENT_ERROR, 'Failed to add assistant: ' + error.message);
      }
    }),

    updateAssistant: flow(function* (_id: string, assistant: IAssistant) {
      try {
        const updatedAssistant = yield updateAssistant(_id, assistant);
        const index = self.assistants.findIndex((ass) => ass._id === _id);

        self.assistants[index] = updatedAssistant;
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'assistant has been deleted successfully'
        );
      } catch (error) {
        console.error('Failed to update assistant', error);
      }
    }),

    deleteAssistant: flow(function* (_id: string) {
      try {
        yield deleteAssistant(_id);
        const index = self.assistants.findIndex(
          (assistant) => assistant._id === _id
        );
        if (index !== -1) {
          self.assistants.splice(index, 1);
        }
        emitter.emit(
          EVENT_SHOW_NOTIFICATION,
          'Assistant has been deleted successfully'
        );
      } catch (error) {
        console.error('Failed to delete assistant', error);
      }
    }),

    getAssistantById: (_id: string) => {
      return self.assistants.find((assistant) => assistant._id === _id);
    },
  }));

export interface IRootStore extends Instance<typeof RootStore> {}
export { RootStore };


store/models/Session.ts:
import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';

const Session = types.model('Session', {
  _id: types.identifier,
  companyId: types.string,
  companyName: types.string,
  userId: types.string,
  assistantId: types.string,
  threadId: types.string,
  active: types.boolean,
  assistantName: types.string,
  userName: types.string  
});

type ISession = Instance<typeof Session>;
type SessionSnapshotIn = SnapshotIn<typeof Session>;
type SessionSnapshotOut = SnapshotOut<typeof Session>;
export type SessionKeys = keyof ISession;

export { Session };
export type { ISession, SessionSnapshotIn, SessionSnapshotOut };


store/models/SessionStore.ts:
// src/store/models/SessionStore.ts
import { types, flow, Instance, applySnapshot, clone } from 'mobx-state-tree';
import { ISession, Session } from './Session';
import {
  deleteSession,
  getAllSessions,
  getLocalStorageItem,
  LOCALSTORAGE_COMPANY_ID,
} from '../../services/api/sessionService';

const SessionStore = types
  .model({
    sessions: types.array(Session),
    activeSession: types.maybe(Session),
  })
  .actions((self) => ({
    loadSessions: flow(function* () {
      try {
        const sessions = yield getAllSessions(
          getLocalStorageItem(LOCALSTORAGE_COMPANY_ID) || ''
        );
        applySnapshot(self.sessions, sessions);
      } catch (error) {
        console.error('Failed to load sessions', error);
      }
    }),

    setActiveSession: (session: ISession) => {
      self.activeSession = session;
    },

    clearActiveSession: () => {
      self.activeSession = undefined;
    },

    setActiveSessionById: (_id: string) => {
      const session = self.sessions.find((session) => session._id === _id);
      if (session) {
        self.activeSession = clone(session);
      } else {
        console.error('Session not found with ID:', _id);
      }
    },

    deleteSession: flow(function* (_id: string) {
      try {
        yield deleteSession(_id);
        const index = self.sessions.findIndex((session) => session._id === _id);
        if (index !== -1) {
          self.sessions[index].active = false;
        }
      } catch (error) {
        console.error('Failed to delete session', error);
      }
    }),
  }));

export interface ISessionStore extends Instance<typeof SessionStore> {}
export { SessionStore };


store/models/User.ts:
import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';
import { Identifier } from './Assistant';

const User = types.model('User', {
  _id: types.identifier,
  name: types.string,
  nickname: types.string,
  identifiers: types.optional(types.array(Identifier), []),
});

type IUser = Instance<typeof User>;
type UserSnapshotIn = SnapshotIn<typeof User>;
type UserSnapshotOut = SnapshotOut<typeof User>;
export type UserKeys = keyof IUser;

export { User };
export type { IUser, UserSnapshotIn, UserSnapshotOut };


utils/eventNames.ts:
// export const EVENT_ASSISTANT_UPDATED = 'assistant-updated';
// export const EVENT_ASSISTANT_DELETED = 'assistant-deleted';
// export const EVENT_ASSISTANT_CREATED = 'assistant-created';
export const EVENT_SET_ACTIVE_ASSISTANT = 'set-active-assistant';
export const EVENT_CHAT_SESSION_DELETED = 'chat-session-deleted';

export const EVENT_SHOW_NOTIFICATION = 'show-notification';


export const EVENT_SHOW_ADD_ASSISTANT_MODAL = 'show-add-assistant-modal';
export const EVENT_SHOW_ADD_COMPANY_MODAL = 'show-add-company-modal';
export const EVENT_SHOW_ADD_USER_MODAL = 'show-add-user-modal';

export const EVENT_CLOSE_MODAL = 'close-modal';
export const EVENT_ERROR = 'error';


export const EVENT_SET_ASSISTANT_VALUES = 'set-assistant-values';

export type EventType =
  // | typeof EVENT_ASSISTANT_UPDATED
  | typeof EVENT_SHOW_ADD_ASSISTANT_MODAL
  // | typeof EVENT_ASSISTANT_DELETED
  // | typeof EVENT_ASSISTANT_CREATED
  | typeof EVENT_CLOSE_MODAL
  | typeof EVENT_ERROR
  | typeof EVENT_SET_ACTIVE_ASSISTANT
  | typeof EVENT_CHAT_SESSION_DELETED
  | typeof EVENT_SET_ASSISTANT_VALUES
  | typeof EVENT_SHOW_ADD_COMPANY_MODAL
  | typeof EVENT_SHOW_ADD_USER_MODAL
  | typeof EVENT_SHOW_NOTIFICATION;



utils/utils.ts:
export const convertToStringArray = <T>(items: T[]): string[] => {
  return items.map((item) => String(item));
};


vite-env.d.ts:
/// <reference types="vite/client" />


